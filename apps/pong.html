<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Retro Pong - Adaptive Orientation</title>
    <style>
        /* Basic reset and full-screen setup */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            background-color: #000;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
        }
        /* Canvas styling */
        canvas {
            display: block;
            background-color: #080808;
        }
        /* Overlay for messages */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.5); /* Slightly more transparent to see fireworks */
            color: #fff;
            font-size: 2em;
            display: none; /* Hidden by default */
        }
        .overlay h1 {
            margin: 0;
            font-size: 2.5em;
            color: #0f0; /* Green for a retro feel */
            text-shadow: 0 0 15px #0f0;
        }
        .overlay p {
            margin-top: 20px;
            font-size: 0.8em;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div id="winnerOverlay" class="overlay">
        <h1 id="winnerText"></h1>
        <p>Click or Tap to Play Again</p>
    </div>

    <canvas id="pongCanvas"></canvas>

    <script>
        const canvas = document.getElementById('pongCanvas');
        const ctx = canvas.getContext('2d');
        const winnerOverlay = document.getElementById('winnerOverlay');
        const winnerText = document.getElementById('winnerText');

        // --- Game Configuration ---
        const PADDLE_WIDTH = 15;
        const PADDLE_HEIGHT_DEFAULT = 100;
        const MIN_PADDLE_SIZE = 40;
        const MAX_PADDLE_SIZE = 200;
        const BALL_RADIUS = 10;
        const PADDLE_SPEED = 8;
        const BASE_AI_SPEED = 6;
        const BASE_BALL_SPEED = 5;
        const WINNING_SCORE = 10;

        let ball, player1, player2, keys, gamepads;
        let scores = { p1: 0, p2: 0 };
        let gameOver = false;
        let audioCtx;
        let particles = [];
        let fireworks = [];
        let fireworksInterval;
        let gameOrientation = 'horizontal';
        let ballSpeed, aiSpeed, bounceFactor; // Dynamic game parameters

        // --- Control Management ---
        let player1Control = null;
        let player2Control = null;
        const controlTypes = {
            KEYBOARD_WS: 'Keyboard (W/S)',
            KEYBOARD_ARROWS: 'Keyboard (Arrows)',
            GAMEPAD_0: 'Gamepad 1',
            GAMEPAD_1: 'Gamepad 2',
            GYRO: 'Gyroscope',
            TOUCH_LEFT: 'Touch (Left)',
            TOUCH_RIGHT: 'Touch (Right)',
            TOUCH_TOP: 'Touch (Top)',
            TOUCH_BOTTOM: 'Touch (Bottom)',
            AI: 'Computer'
        };

        // --- Sound Generation ---
        function setupAudio() {
            // Creates the AudioContext. This must be done after a user interaction on mobile.
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        function playSound(type) {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            const now = audioCtx.currentTime;
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.type = 'sine';

            let duration = 0.15; // default duration

            switch(type) {
                case 'paddle':
                    gainNode.gain.setValueAtTime(0.3, now);
                    oscillator.frequency.setValueAtTime(440, now);
                    break;
                case 'wall':
                    gainNode.gain.setValueAtTime(0.3, now);
                    oscillator.frequency.setValueAtTime(150, now);
                    break;
                case 'score':
                    gainNode.gain.setValueAtTime(0.4, now);
                    oscillator.frequency.setValueAtTime(660, now);
                    break;
                case 'win':
                    duration = 0.8;
                    gainNode.gain.setValueAtTime(0.5, now);
                    oscillator.frequency.setValueAtTime(261.63, now); // C4
                    oscillator.frequency.linearRampToValueAtTime(523.25, now + 0.6); // C5
                    break;
            }
            
            gainNode.gain.linearRampToValueAtTime(0.0001, now + duration);
            oscillator.start(now);
            oscillator.stop(now + duration);
        }

        // --- Game Objects & Setup ---
        function checkOrientation() {
            const oldOrientation = gameOrientation;
            gameOrientation = window.innerWidth > window.innerHeight ? 'horizontal' : 'vertical';
            if (oldOrientation !== gameOrientation && oldOrientation !== null) {
                init(); // Re-initialize if orientation changes
            }
        }

        function createPaddle(playerIndex) {
            const paddle = { speed: PADDLE_SPEED, dx: 0, dy: 0 };
            if (gameOrientation === 'horizontal') {
                paddle.x = playerIndex === 1 ? 30 : canvas.width - 30 - PADDLE_WIDTH;
                paddle.y = canvas.height / 2 - PADDLE_HEIGHT_DEFAULT / 2;
                paddle.width = PADDLE_WIDTH;
                paddle.height = PADDLE_HEIGHT_DEFAULT;
            } else { // vertical
                paddle.x = canvas.width / 2 - PADDLE_HEIGHT_DEFAULT / 2;
                paddle.y = playerIndex === 1 ? 30 : canvas.height - 30 - PADDLE_WIDTH;
                paddle.width = PADDLE_HEIGHT_DEFAULT;
                paddle.height = PADDLE_WIDTH;
            }
            return paddle;
        }
        
        function init() {
            gameOver = false;
            winnerOverlay.style.display = 'none';
            clearInterval(fireworksInterval);
            fireworks = [];
            particles = [];
            player1Control = null;
            player2Control = null;
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            checkOrientation();

            // --- Dynamic Parameter Calculation ---
            const referenceDimension = 800; // A baseline screen size for normal speed
            const speedFactor = Math.min(1.0, Math.max(0.45, Math.min(canvas.width, canvas.height) / referenceDimension));
            
            ballSpeed = BASE_BALL_SPEED * speedFactor;
            aiSpeed = BASE_AI_SPEED * speedFactor;
            
            // Změkčení odrazů na výšku, kde je pálka relativně větší
            bounceFactor = gameOrientation === 'horizontal' ? 0.25 : 0.15;
            // --- End of Dynamic Parameter Calculation ---

            ball = { x: canvas.width / 2, y: canvas.height / 2, radius: BALL_RADIUS, dx: ballSpeed, dy: ballSpeed };
            player1 = createPaddle(1);
            player2 = createPaddle(2);
            
            keys = {};
            gamepads = {};
            scores = { p1: 0, p2: 0 };

            if (!gameOver) requestAnimationFrame(gameLoop);
        }
        
        // --- Event Listeners ---
        function addEventListeners() {
            document.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; detectControl(e.key.toLowerCase()); });
            document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
            window.addEventListener("gamepadconnected", e => gamepads[e.gamepad.index] = e.gamepad);
            window.addEventListener("gamepaddisconnected", e => delete gamepads[e.gamepad.index]);
            window.addEventListener('resize', init); // Re-init on resize handles orientation change
            if ('DeviceOrientationEvent' in window) window.addEventListener('deviceorientation', e => { if(e.gamma !== null) { assignControl(controlTypes.GYRO); handleGyro(e); } });
            canvas.addEventListener('touchstart', handleTouch, { passive: false });
            canvas.addEventListener('touchmove', handleTouch, { passive: false });
            const startListener = e => { if (gameOver) { e.preventDefault(); init(); } };
            document.body.addEventListener('click', startListener);
            document.body.addEventListener('touchend', startListener);
        }
        
        // --- Input Handling ---
        function handleTouch(e) {
            // Okamžitá inicializace zvuku při prvním dotyku
            setupAudio();
            e.preventDefault();
            for (const touch of e.touches) {
                if (gameOrientation === 'horizontal') {
                    const side = touch.clientX < canvas.width / 2 ? controlTypes.TOUCH_LEFT : controlTypes.TOUCH_RIGHT;
                    assignControl(side);
                    const paddle = (player1Control === side) ? player1 : player2;
                    if (paddle) paddle.y = touch.clientY - paddle.height / 2;
                } else { // vertical
                    const side = touch.clientY < canvas.height / 2 ? controlTypes.TOUCH_TOP : controlTypes.TOUCH_BOTTOM;
                    assignControl(side);
                    const paddle = (player1Control === side) ? player1 : player2;
                    if (paddle) paddle.x = touch.clientX - paddle.width / 2;
                }
            }
        }

        function handleGyro(e) {
            setupAudio(); // Also init audio on gyro movement
            const paddle = (player1Control === controlTypes.GYRO) ? player1 : player2;
            if (!paddle) return;
            if (gameOrientation === 'horizontal') {
                let tilt = Math.max(-60, Math.min(60, e.gamma)); // left-right
                paddle.y = ((tilt + 60) / 120) * (canvas.height - paddle.height);
            } else {
                let tilt = Math.max(-60, Math.min(60, e.beta)); // front-back
                paddle.x = ((tilt + 60) / 120) * (canvas.width - paddle.width);
            }
        }

        function assignControl(type) {
            setupAudio(); // Init audio on any control assignment
            if (!player1Control) player1Control = type;
            else if (!player2Control && player1Control !== type) player2Control = type;
        }

        function detectControl(key) {
            if (['w', 's'].includes(key)) assignControl(controlTypes.KEYBOARD_WS);
            else if (['arrowup', 'arrowdown'].includes(key)) assignControl(controlTypes.KEYBOARD_ARROWS);
        }

        function getPlayerVelocity(control, gamepads) {
            switch (control) {
                case controlTypes.KEYBOARD_WS: return (keys['w'] ? -PADDLE_SPEED : (keys['s'] ? PADDLE_SPEED : 0));
                case controlTypes.KEYBOARD_ARROWS: return (keys['arrowup'] ? -PADDLE_SPEED : (keys['arrowdown'] ? PADDLE_SPEED : 0));
                case controlTypes.GAMEPAD_0: if (gamepads[0]) { const axis = gamepads[0].axes[1]; if (Math.abs(axis) > 0.1) return axis * PADDLE_SPEED; } return 0;
                case controlTypes.GAMEPAD_1: if (gamepads[1]) { const axis = gamepads[1].axes[1]; if (Math.abs(axis) > 0.1) return axis * PADDLE_SPEED; } return 0;
                default: return 0;
            }
        }
        
        function handlePaddleSizeChange(player, control, gamepads) {
            let change = 0;
            const sizeTarget = gameOrientation === 'horizontal' ? 'height' : 'width';
            switch(control) {
                case controlTypes.KEYBOARD_WS: if(keys['a']) change = -5; if(keys['d']) change = 5; break;
                case controlTypes.KEYBOARD_ARROWS: if(keys['j']) change = -5; if(keys['l']) change = 5; break;
                case controlTypes.GAMEPAD_0: if(gamepads[0]?.buttons[14]?.pressed) change = -5; if(gamepads[0]?.buttons[15]?.pressed) change = 5; break;
                case controlTypes.GAMEPAD_1: if(gamepads[1]?.buttons[14]?.pressed) change = -5; if(gamepads[1]?.buttons[15]?.pressed) change = 5; break;
            }
            if (change !== 0) {
                player[sizeTarget] += change;
                player[sizeTarget] = Math.max(MIN_PADDLE_SIZE, Math.min(MAX_PADDLE_SIZE, player[sizeTarget]));
            }
        }
        
        // --- Game Logic ---
        function update() {
            const connectedGamepads = navigator.getGamepads();
            if (connectedGamepads[0]) assignControl(controlTypes.GAMEPAD_0);
            if (connectedGamepads[1]) assignControl(controlTypes.GAMEPAD_1);
            
            const p1Vel = getPlayerVelocity(player1Control, connectedGamepads);
            const p2Vel = getPlayerVelocity(player2Control, connectedGamepads);

            if (gameOrientation === 'horizontal') { player1.dy = p1Vel; player2.dy = p2Vel; } 
            else { player1.dx = p1Vel; player2.dx = p2Vel; }

            handlePaddleSizeChange(player1, player1Control, connectedGamepads);
            handlePaddleSizeChange(player2, player2Control, connectedGamepads);

            movePaddles();
            moveBall();
            handleCollisions();
            updateParticles();
        }

        function movePaddles() {
            const isP1Manual = ![controlTypes.GYRO, controlTypes.TOUCH_LEFT, controlTypes.TOUCH_RIGHT, controlTypes.TOUCH_TOP, controlTypes.TOUCH_BOTTOM].includes(player1Control);
            const isP2Manual = ![controlTypes.GYRO, controlTypes.TOUCH_LEFT, controlTypes.TOUCH_RIGHT, controlTypes.TOUCH_TOP, controlTypes.TOUCH_BOTTOM].includes(player2Control);

            if (gameOrientation === 'horizontal') {
                if (isP1Manual) player1.y += player1.dy;
                if (isP2Manual) player2.y += player2.dy;
                player1.y = Math.max(0, Math.min(canvas.height - player1.height, player1.y));
                if (!player2Control) { // AI
                    const p2Center = player2.y + player2.height / 2;
                    if (p2Center < ball.y - 20) player2.y += aiSpeed; else if (p2Center > ball.y + 20) player2.y -= aiSpeed;
                }
                player2.y = Math.max(0, Math.min(canvas.height - player2.height, player2.y));
            } else { // vertical
                if (isP1Manual) player1.x += player1.dx;
                if (isP2Manual) player2.x += player2.dx;
                player1.x = Math.max(0, Math.min(canvas.width - player1.width, player1.x));
                if (!player2Control) { // AI
                    const p2Center = player2.x + player2.width / 2;
                    if (p2Center < ball.x - 20) player2.x += aiSpeed; else if (p2Center > ball.x + 20) player2.x -= aiSpeed;
                }
                player2.x = Math.max(0, Math.min(canvas.width - player2.width, player2.x));
            }
        }

        function moveBall() {
            ball.x += ball.dx;
            ball.y += ball.dy;
            if (gameOrientation === 'horizontal') {
                if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) { ball.dy *= -1; playSound('wall'); }
                if (ball.x > canvas.width) { scores.p1++; playSound('score'); checkWin(); resetBall(); }
                if (ball.x < 0) { scores.p2++; playSound('score'); checkWin(); resetBall(); }
            } else { // vertical
                if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) { ball.dx *= -1; playSound('wall'); }
                if (ball.y > canvas.height) { scores.p1++; playSound('score'); checkWin(); resetBall(); }
                if (ball.y < 0) { scores.p2++; playSound('score'); checkWin(); resetBall(); }
            }
        }
        
        function handleCollisions() {
            if (gameOrientation === 'horizontal') {
                const hitP1 = ball.dx < 0 && ball.x - ball.radius < player1.x + player1.width && ball.y > player1.y && ball.y < player1.y + player1.height;
                const hitP2 = ball.dx > 0 && ball.x + ball.radius > player2.x && ball.y > player2.y && ball.y < player2.y + player2.height;
                if (hitP1 || hitP2) {
                    ball.dx *= -1.02;
                    let paddle = hitP1 ? player1 : player2;
                    ball.dy = (ball.y - (paddle.y + paddle.height / 2)) * bounceFactor;
                    playSound('paddle'); createSparkles(ball.x, ball.y);
                }
            } else { // vertical
                const hitP1 = ball.dy < 0 && ball.y - ball.radius < player1.y + player1.height && ball.x > player1.x && ball.x < player1.x + player1.width;
                const hitP2 = ball.dy > 0 && ball.y + ball.radius > player2.y && ball.x > player2.x && ball.x < player2.x + player2.width;
                if (hitP1 || hitP2) {
                    ball.dy *= -1.02;
                    let paddle = hitP1 ? player1 : player2;
                    ball.dx = (ball.x - (paddle.x + paddle.width / 2)) * bounceFactor;
                    playSound('paddle'); createSparkles(ball.x, ball.y);
                }
            }
        }
        
        function checkWin() {
            if (scores.p1 >= WINNING_SCORE) { winnerText.textContent = "Player 1 Wins!"; endGame(); } 
            else if (scores.p2 >= WINNING_SCORE) { winnerText.textContent = (player2Control ? "Player 2" : "Computer") + " Wins!"; endGame(); }
        }
        
        function endGame() {
            gameOver = true;
            playSound('win');
            winnerOverlay.style.display = 'flex';
            clearInterval(fireworksInterval);
            fireworksInterval = setInterval(createFirework, 500);
            createFirework();
            requestAnimationFrame(overlayLoop);
        }

        function resetBall() {
            if (gameOver) return;
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.dx = ballSpeed * (Math.random() > 0.5 ? 1 : -1);
            ball.dy = ballSpeed * (Math.random() > 0.5 ? 1 : -1);
        }

        // --- Particle Effects & Drawing ---
        function createSparkles(x, y) { for (let i = 0; i < 15; i++) particles.push({ x, y, dx: (Math.random()-0.5)*4, dy: (Math.random()-0.5)*4, size: Math.random()*3+1, life: 30 }); }
        function updateParticles() { for (let i = particles.length - 1; i >= 0; i--) { let p = particles[i]; p.x += p.dx; p.y += p.dy; p.life--; if (p.life <= 0) particles.splice(i, 1); } }
        function drawParticles() { particles.forEach(p => { ctx.fillStyle = `rgba(255, 255, 255, ${p.life / 30})`; ctx.fillRect(p.x, p.y, p.size, p.size); }); }
        function createFirework() { const x=Math.random()*canvas.width, y=Math.random()*canvas.height/2, h=Math.random()*360; for(let i=0;i<50;i++){ const a=Math.random()*Math.PI*2, s=Math.random()*5+2; fireworks.push({x,y,dx:Math.cos(a)*s,dy:Math.sin(a)*s,size:Math.random()*3+1,life:60+Math.random()*20,color:`hsl(${h},100%,50%)`});}}
        function updateFireworks() { for (let i = fireworks.length - 1; i >= 0; i--) { let p = fireworks[i]; p.x += p.dx; p.y += p.dy; p.dy += 0.1; p.life--; if (p.life <= 0) fireworks.splice(i, 1); } }
        function drawFireworks() { fireworks.forEach(p => { ctx.globalAlpha = p.life / 80; ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size); }); ctx.globalAlpha = 1.0; }
        function drawRect(x, y, w, h) { ctx.fillStyle = '#fff'; ctx.fillRect(x, y, w, h); }
        function drawCircle(x, y, r) { ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill(); }
        function drawNet() {
            ctx.beginPath();
            ctx.setLineDash([10, 15]);
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 4;
            if (gameOrientation === 'horizontal') { ctx.moveTo(canvas.width / 2, 0); ctx.lineTo(canvas.width / 2, canvas.height); } 
            else { ctx.moveTo(0, canvas.height / 2); ctx.lineTo(canvas.width, canvas.height / 2); }
            ctx.stroke();
            ctx.setLineDash([]);
        }
        function drawScores() {
            ctx.font = '50px "Courier New", Courier, monospace';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            if (gameOrientation === 'horizontal') {
                ctx.fillText(scores.p1, canvas.width / 4, 60);
                ctx.fillText(scores.p2, 3 * canvas.width / 4, 60);
            } else {
                ctx.fillText(scores.p1, 60, canvas.height / 4);
                ctx.fillText(scores.p2, 60, 3 * canvas.height / 4);
            }
        }
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawNet();
            drawRect(player1.x, player1.y, player1.width, player1.height);
            drawRect(player2.x, player2.y, player2.width, player2.height);
            drawCircle(ball.x, ball.y, ball.radius);
            drawParticles();
            drawScores();
        }

        // --- Game Loops ---
        function gameLoop() { if (!gameOver) { update(); draw(); requestAnimationFrame(gameLoop); } }
        function overlayLoop() { if (gameOver) { ctx.clearRect(0, 0, canvas.width, canvas.height); updateFireworks(); drawFireworks(); requestAnimationFrame(overlayLoop); } }

        // --- Start ---
        addEventListeners();
        init();
    </script>
</body>
</html>
