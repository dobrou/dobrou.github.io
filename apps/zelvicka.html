import React, { useState, useEffect, useRef } from 'react';
import { ArrowUp, RotateCcw, RotateCw, Play, Trash2, RefreshCw, Flame, Volume2, VolumeX, Zap, Snail, Rabbit, List, Lock, Check, Gauge } from 'lucide-react';

// Konstanty hry
const GRID_SIZE = 6;
const DIRECTIONS = [
  { label: 'Sever', dx: 0, dy: -1, rotate: 0 },   // 0: Nahoru
  { label: 'V√Ωchod', dx: 1, dy: 0, rotate: 90 },  // 1: Doprava
  { label: 'Jih', dx: 0, dy: 1, rotate: 180 },    // 2: Dol≈Ø
  { label: 'Z√°pad', dx: -1, dy: 0, rotate: 270 }  // 3: Doleva
];

// Zvukov√Ω syntez√°tor
const playSound = (type) => {
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (!AudioContext) return;
    
    const ctx = new AudioContext();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    
    osc.connect(gain);
    gain.connect(ctx.destination);
    
    const now = ctx.currentTime;
    
    if (type === 'step') {
      osc.type = 'sine';
      osc.frequency.setValueAtTime(440, now);
      osc.frequency.exponentialRampToValueAtTime(880, now + 0.1);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
      osc.start(now);
      osc.stop(now + 0.1);
    } else if (type === 'turn') {
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(300, now);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.linearRampToValueAtTime(0.01, now + 0.1);
      osc.start(now);
      osc.stop(now + 0.1);
    } else if (type === 'fire') {
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(800, now);
      osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
      osc.start(now);
      osc.stop(now + 0.3);
    } else if (type === 'win') {
      osc.type = 'square';
      [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
        const osc2 = ctx.createOscillator();
        const gain2 = ctx.createGain();
        osc2.connect(gain2);
        gain2.connect(ctx.destination);
        osc2.frequency.value = freq;
        gain2.gain.setValueAtTime(0.05, now + i*0.1);
        gain2.gain.exponentialRampToValueAtTime(0.001, now + i*0.1 + 0.3);
        osc2.start(now + i*0.1);
        osc2.stop(now + i*0.1 + 0.3);
      });
    } else if (type === 'lose') {
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(150, now);
      osc.frequency.linearRampToValueAtTime(50, now + 0.5);
      gain.gain.setValueAtTime(0.2, now);
      gain.gain.linearRampToValueAtTime(0.01, now + 0.5);
      osc.start(now);
      osc.stop(now + 0.5);
    } else if (type === 'click') {
      osc.type = 'sine';
      osc.frequency.setValueAtTime(800, now);
      gain.gain.setValueAtTime(0.05, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
      osc.start(now);
      osc.stop(now + 0.05);
    }
  } catch (e) {
    // Silent fail
  }
};

export default function TurtleGame() {
  const [turtle, setTurtle] = useState({ x: 0, y: 0, dir: 1 });
  const [walls, setWalls] = useState([]); 
  const [iceWalls, setIceWalls] = useState([]); 
  
  const [startTurtle, setStartTurtle] = useState({ x: 0, y: 0, dir: 1 });
  const [initialWalls, setInitialWalls] = useState([]);
  const [initialIceWalls, setInitialIceWalls] = useState([]);

  const [diamond, setDiamond] = useState({ x: 5, y: 5 });
  
  const [program, setProgram] = useState([]);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentStep, setCurrentStep] = useState(-1);
  const [gameStatus, setGameStatus] = useState('idle');
  const [message, setMessage] = useState("Dosta≈à ≈æelviƒçku k diamantu!");
  
  const [speed, setSpeed] = useState(400); 
  const [soundEnabled, setSoundEnabled] = useState(true);

  const [projectile, setProjectile] = useState(null);

  // Drag & Drop State
  const [draggedItemIndex, setDraggedItemIndex] = useState(null);
  const [dropTargetIndex, setDropTargetIndex] = useState(null); // Index p≈ôed kter√Ω vkl√°d√°me

  const safePlaySound = (type) => {
    if (soundEnabled) playSound(type);
  };

  const initGame = () => {
    setProgram([]);
    setCurrentStep(-1);
    setIsPlaying(false);
    setGameStatus('idle');
    setProjectile(null);
    setMessage("Dosta≈à ≈æelviƒçku k diamantu!");

    let newTurtle = { x: 0, y: 0, dir: 1 };
    let newDiamond = { x: GRID_SIZE - 1, y: GRID_SIZE - 1 };
    
    let newWalls = [];
    let newIceWalls = [];
    
    const generateObstacles = (count, array, otherArray) => {
      for (let i = 0; i < count; i++) {
        let attempts = 0;
        while (attempts < 20) {
          let wx = Math.floor(Math.random() * GRID_SIZE);
          let wy = Math.floor(Math.random() * GRID_SIZE);
          
          const isTaken = 
            (wx === newTurtle.x && wy === newTurtle.y) || 
            (wx === newDiamond.x && wy === newDiamond.y) ||
            newWalls.some(w => w.x === wx && w.y === wy) ||
            newIceWalls.some(w => w.x === wx && w.y === wy);

          if (!isTaken) {
            array.push({ x: wx, y: wy });
            break;
          }
          attempts++;
        }
      }
    };

    generateObstacles(6, newWalls, newIceWalls);
    generateObstacles(5, newIceWalls, newWalls);

    setTurtle(newTurtle);
    setWalls(newWalls);
    setIceWalls(newIceWalls);
    setDiamond(newDiamond);

    setStartTurtle({ ...newTurtle });
    setInitialWalls([...newWalls]);
    setInitialIceWalls([...newIceWalls]);
  };

  useEffect(() => {
    initGame();
  }, []);

  const addCommand = (type) => {
    if (gameStatus !== 'idle' && gameStatus !== 'lost' && gameStatus !== 'won') return;
    safePlaySound('click');
    if (gameStatus === 'lost' || gameStatus === 'won') {
        setGameStatus('idle');
        setTurtle(startTurtle);
        setWalls(initialWalls);
        setIceWalls(initialIceWalls);
    }
    setProgram([...program, { id: Date.now() + Math.random(), type }]);
  };

  const removeCommand = (index) => {
    if (isPlaying) return;
    safePlaySound('click');
    const newProgram = [...program];
    newProgram.splice(index, 1);
    setProgram(newProgram);
    setGameStatus('idle');
  };

  const clearProgram = () => {
    if (isPlaying) return;
    safePlaySound('click');
    setProgram([]);
    setGameStatus('idle');
    setTurtle(startTurtle);
    setWalls(initialWalls);
    setIceWalls(initialIceWalls);
  };

  // --- Drag & Drop Logika ---
  
  const handleDragStart = (e, index) => {
    setDraggedItemIndex(index);
    e.dataTransfer.effectAllowed = "move";
    // Trik pro "neviditeln√©" ta≈æen√≠ origin√°lu, aby byl vidƒõt jen kurzor/ghost
    // Ale u Reactu je lep≈°√≠ nechat origin√°l viditeln√Ω a jen ho "vy≈°ednout" pomoc√≠ CSS t≈ô√≠dy
  };

  const handleDragOver = (e, index) => {
    e.preventDefault(); // Nutn√© aby fungoval Drop
    e.dataTransfer.dropEffect = "move";
    
    // Pokud jsme nad jinou polo≈ækou, ne≈æ kterou t√°hneme, nastav√≠me ji jako c√≠l
    // C√≠lem je index, P≈òED kter√Ω se m√° prvek vlo≈æit
    if (draggedItemIndex === null) return;

    if (index !== dropTargetIndex) {
        setDropTargetIndex(index);
    }
  };

  const handleDragLeave = (e) => {
      // Voliteln√©: vyƒçi≈°tƒõn√≠ targetu, pokud opust√≠me kontejner
      // Ale v praxi to zp≈Øsobuje blik√°n√≠, kdy≈æ p≈ôej√≠≈æd√≠me mezi dƒõtmi
  }
  
  // Speci√°ln√≠ z√≥na na konci seznamu
  const handleDragOverEnd = (e) => {
      e.preventDefault();
      if (draggedItemIndex === null) return;
      
      // Pokud jsme na konci, c√≠lov√Ω index je d√©lka pole
      const endIndex = program.length;
      if (dropTargetIndex !== endIndex) {
          setDropTargetIndex(endIndex);
      }
  }

  const handleDrop = (e) => {
    e.preventDefault();
    
    if (draggedItemIndex === null || dropTargetIndex === null) return;
    
    const newProgram = [...program];
    const itemToMove = newProgram[draggedItemIndex];
    
    // 1. Odstran√≠me prvek ze star√© pozice
    newProgram.splice(draggedItemIndex, 1);
    
    // 2. Vypoƒç√≠t√°me novou pozici pro vlo≈æen√≠
    // Pokud jsme brali prvek z men≈°√≠ho indexu ne≈æ je c√≠l, c√≠l se po odstranƒõn√≠ posunul o -1
    let insertionIndex = dropTargetIndex;
    if (draggedItemIndex < dropTargetIndex) {
        insertionIndex -= 1;
    }
    
    // 3. Vlo≈æ√≠me na novou pozici
    newProgram.splice(insertionIndex, 0, itemToMove);
    
    setProgram(newProgram);
    setDraggedItemIndex(null);
    setDropTargetIndex(null);
    safePlaySound('click');
  };

  const handleDragEnd = () => {
      setDraggedItemIndex(null);
      setDropTargetIndex(null);
  };

  const runProgram = async () => {
    if (program.length === 0) return;
    
    setIsPlaying(true);
    setGameStatus('running');
    setCurrentStep(-1);
    setMessage("Pozor, start!");
    safePlaySound('click');

    setTurtle(startTurtle);
    setWalls(initialWalls);
    setIceWalls(initialIceWalls);
    setProjectile(null);

    await new Promise(r => setTimeout(r, 500));
    setMessage("Jedu!");

    let currentTurtle = { ...startTurtle };
    let currentWalls = [...initialWalls];
    let currentIceWalls = [...initialIceWalls];

    for (let i = 0; i < program.length; i++) {
      setCurrentStep(i);
      const cmd = program[i];
      
      await new Promise(r => setTimeout(r, speed));

      const move = DIRECTIONS[currentTurtle.dir];
      
      if (cmd.type === 'FORWARD') {
        const nextX = currentTurtle.x + move.dx;
        const nextY = currentTurtle.y + move.dy;

        const hitWall = currentWalls.some(w => w.x === nextX && w.y === nextY);
        const hitIce = currentIceWalls.some(w => w.x === nextX && w.y === nextY);
        const outOfBounds = nextX < 0 || nextX >= GRID_SIZE || nextY < 0 || nextY >= GRID_SIZE;

        if (hitWall || hitIce || outOfBounds) {
          setGameStatus('lost');
          safePlaySound('lose');
          if (hitWall) setMessage("Au! K√°men!");
          else if (hitIce) setMessage("Brrr! Led!");
          else setMessage("Au! Okraj!");
          setIsPlaying(false);
          return; 
        }

        currentTurtle.x = nextX;
        currentTurtle.y = nextY;
        safePlaySound('step');
      } 
      else if (cmd.type === 'LEFT') {
        currentTurtle.dir = (currentTurtle.dir + 3) % 4;
        safePlaySound('turn');
      } 
      else if (cmd.type === 'RIGHT') {
        currentTurtle.dir = (currentTurtle.dir + 1) % 4;
        safePlaySound('turn');
      }
      else if (cmd.type === 'MELT') {
        const targetX = currentTurtle.x + move.dx;
        const targetY = currentTurtle.y + move.dy;

        safePlaySound('fire');
        setProjectile({
            x: currentTurtle.x,
            y: currentTurtle.y,
            targetX: currentTurtle.x + move.dx * 0.8, 
            targetY: currentTurtle.y + move.dy * 0.8,
            type: 'fire',
            rotation: DIRECTIONS[currentTurtle.dir].rotate
        });

        await new Promise(r => setTimeout(r, 300));
        setProjectile(null);
        
        const iceIndex = currentIceWalls.findIndex(w => w.x === targetX && w.y === targetY);
        
        if (iceIndex !== -1) {
          currentIceWalls.splice(iceIndex, 1);
          setIceWalls([...currentIceWalls]);
          setMessage("Psss...");
        } else {
           setMessage("Nic.");
        }
      }

      setTurtle({ ...currentTurtle });

      if (currentTurtle.x === diamond.x && currentTurtle.y === diamond.y) {
        setGameStatus('won');
        safePlaySound('win');
        setMessage("Hur√°! Diamant!");
        setIsPlaying(false);
        return;
      }
    }

    if (gameStatus !== 'won') {
      setIsPlaying(false);
      setGameStatus('lost');
      setMessage("Konec programu...");
    }
  };

  const ActionCard = ({ icon: Icon, onClick, colorClass }) => (
    <button
      onClick={onClick}
      disabled={isPlaying}
      className={`w-14 h-14 sm:w-16 sm:h-16 flex items-center justify-center rounded-2xl shadow-lg border-2 border-slate-700 transition-all transform hover:-translate-y-1 active:translate-y-1 active:shadow-none disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none ${colorClass} bg-slate-800`}
    >
      <Icon size={32} strokeWidth={3} />
    </button>
  );

  return (
    <div className="min-h-screen bg-slate-900 text-slate-200 p-2 sm:p-4 font-sans flex flex-col items-center select-none">
      
      {/* Hlaviƒçka */}
      <header className="w-full max-w-4xl flex flex-wrap justify-between items-center mb-6 bg-slate-800 p-3 rounded-2xl shadow-xl border border-slate-700 gap-4">
        <div className="flex items-center gap-3">
          <div className="bg-emerald-600 text-white p-2 rounded-xl shadow-lg shadow-emerald-900/50">
             <span className="text-2xl">üê¢</span>
          </div>
        </div>
        
        <div className="flex items-center gap-6">
            <div className="flex items-center gap-1 bg-slate-900 p-1.5 rounded-xl border border-slate-700">
                <Gauge size={16} className="text-slate-500 mr-2 ml-1" />
                <button 
                    onClick={() => setSpeed(800)} 
                    className={`p-2 rounded-lg transition-all ${speed === 800 ? 'bg-emerald-600 text-white shadow-md' : 'text-slate-500 hover:text-slate-300'}`}
                >
                    <Snail size={20} />
                </button>
                <button 
                    onClick={() => setSpeed(400)} 
                    className={`p-2 rounded-lg transition-all ${speed === 400 ? 'bg-emerald-600 text-white shadow-md' : 'text-slate-500 hover:text-slate-300'}`}
                >
                    <Rabbit size={20} />
                </button>
                <button 
                    onClick={() => setSpeed(150)} 
                    className={`p-2 rounded-lg transition-all ${speed === 150 ? 'bg-emerald-600 text-white shadow-md' : 'text-slate-500 hover:text-slate-300'}`}
                >
                    <Zap size={20} />
                </button>
            </div>

            <button 
                onClick={() => setSoundEnabled(!soundEnabled)}
                className={`p-3 rounded-xl border-2 transition-colors ${soundEnabled ? 'bg-slate-700 border-slate-600 text-emerald-400' : 'bg-slate-900 border-slate-800 text-slate-600'}`}
            >
                {soundEnabled ? <Volume2 size={24} /> : <VolumeX size={24} />}
            </button>

            <button 
              onClick={initGame} 
              disabled={isPlaying}
              className="p-3 bg-slate-700 hover:bg-slate-600 text-white rounded-xl transition-all disabled:opacity-50 border-2 border-slate-600 hover:border-slate-500 shadow-lg active:scale-95"
            >
              <RefreshCw size={24} />
            </button>
        </div>
      </header>

      <main className="w-full max-w-5xl grid grid-cols-1 lg:grid-cols-2 gap-8">
        
        {/* LEV√Å ƒå√ÅST: Hrac√≠ plocha */}
        <div className="flex flex-col items-center order-1 lg:order-none">
          <div className="bg-slate-800 p-3 rounded-3xl shadow-2xl border-4 border-slate-700 relative">
            
            <div 
              className="grid bg-slate-900 border-2 border-slate-600 relative overflow-hidden rounded-xl"
              style={{ 
                  gridTemplateColumns: `repeat(${GRID_SIZE}, minmax(0, 1fr))`,
                  gridTemplateRows: `repeat(${GRID_SIZE}, minmax(0, 1fr))`,
                  width: 'min(80vw, 400px)',
                  height: 'min(80vw, 400px)' 
              }}
            >
              {Array.from({ length: GRID_SIZE * GRID_SIZE }).map((_, idx) => {
                const x = idx % GRID_SIZE;
                const y = Math.floor(idx / GRID_SIZE);
                const isDiamond = diamond.x === x && diamond.y === y;
                const isWall = walls.some(w => w.x === x && w.y === y);
                const isIce = iceWalls.some(w => w.x === x && w.y === y);

                return (
                  <div key={idx} className="bg-slate-800/30 border border-slate-700/30 w-full h-full flex items-center justify-center relative overflow-hidden">
                    {isDiamond && (
                      <div className="text-cyan-400 animate-pulse text-4xl drop-shadow-[0_0_15px_rgba(34,211,238,0.6)] z-0">
                        üíé
                      </div>
                    )}
                    {isWall && (
                      <div className="w-[85%] h-[85%] bg-stone-700 border-b-4 border-r-4 border-stone-900 rounded-lg shadow-lg relative">
                        <div className="absolute top-1 left-1 opacity-20"><Lock size={12}/></div>
                      </div>
                    )}
                    {isIce && (
                      <div className="w-[85%] h-[85%] bg-cyan-500/40 border-2 border-cyan-300/60 rounded-lg shadow-[inset_0_0_10px_rgba(34,211,238,0.3)] backdrop-blur-sm flex items-center justify-center">
                         <div className="w-full h-[1px] bg-white/30 rotate-45 transform scale-150"></div>
                         <div className="w-full h-[1px] bg-white/30 -rotate-45 transform scale-150"></div>
                      </div>
                    )}
                  </div>
                );
              })}

              <div 
                className="absolute w-[16.66%] h-[16.66%] flex items-center justify-center transition-all ease-in-out z-20 pointer-events-none"
                style={{ 
                    left: `${turtle.x * (100/GRID_SIZE)}%`, 
                    top: `${turtle.y * (100/GRID_SIZE)}%`,
                    transform: `rotate(${DIRECTIONS[turtle.dir].rotate}deg)`,
                    transitionDuration: `${speed}ms` 
                }}
              >
                 <div className="w-[80%] h-[80%] relative">
                    <svg viewBox="0 0 100 100" className="w-full h-full drop-shadow-xl filter brightness-110">
                        <path d="M15 25 L5 15 M85 25 L95 15 M15 75 L5 85 M85 75 L95 85" 
                              stroke="#16a34a" strokeWidth="10" strokeLinecap="round" />
                        <circle cx="50" cy="15" r="16" fill="#16a34a" />
                        <ellipse cx="50" cy="55" rx="34" ry="40" fill="#22c55e" stroke="#15803d" strokeWidth="4" />
                        <path d="M50 30 L65 45 L50 60 L35 45 Z" fill="#4ade80" opacity="0.5" />
                        <path d="M50 60 L65 75 L50 90 L35 75 Z" fill="#4ade80" opacity="0.5" />
                    </svg>
                 </div>
              </div>

              {projectile && (
                <div 
                    className="absolute w-[16.66%] h-[16.66%] flex items-center justify-center z-30 transition-all duration-300 ease-linear pointer-events-none"
                    style={{ 
                        left: `${(projectile.targetX) * (100/GRID_SIZE)}%`, 
                        top: `${(projectile.targetY) * (100/GRID_SIZE)}%`,
                    }}
                >   
                   <div className="text-4xl animate-bounce drop-shadow-[0_0_15px_orange]">üî•</div>
                </div>
              )}
            </div>
          </div>
          
          <div className={`mt-6 px-8 py-4 rounded-full font-bold text-center w-full max-w-md shadow-xl transition-all duration-300 border-2 text-xl tracking-wide
            ${gameStatus === 'won' ? 'bg-emerald-500 text-white border-emerald-400 scale-105' : 
              gameStatus === 'lost' ? 'bg-red-500 text-white border-red-400 shake' : 
              'bg-slate-800 text-slate-300 border-slate-600'}`}>
            {message}
          </div>
        </div>

        {/* PRAV√Å ƒå√ÅST: Ovl√°d√°n√≠ */}
        <div className="flex flex-col gap-4 h-full">
          
          <div className="bg-slate-800 p-6 rounded-3xl shadow-xl border border-slate-700">
            <div className="flex justify-center gap-4 flex-wrap">
              <ActionCard 
                icon={ArrowUp} 
                onClick={() => addCommand('FORWARD')} 
                colorClass="border-blue-500/50 text-blue-400 hover:bg-blue-500/20 hover:border-blue-400" 
              />
              <ActionCard 
                icon={RotateCcw} 
                onClick={() => addCommand('LEFT')} 
                colorClass="border-purple-500/50 text-purple-400 hover:bg-purple-500/20 hover:border-purple-400" 
              />
              <ActionCard 
                icon={RotateCw} 
                onClick={() => addCommand('RIGHT')} 
                colorClass="border-purple-500/50 text-purple-400 hover:bg-purple-500/20 hover:border-purple-400" 
              />
              <div className="w-[2px] bg-slate-700 mx-2 rounded-full"></div>
              
              <ActionCard 
                icon={Flame} 
                onClick={() => addCommand('MELT')} 
                colorClass="border-orange-500/50 text-orange-500 hover:bg-orange-500/20 hover:border-orange-400" 
              />
            </div>
            
            <div className="flex justify-center gap-8 mt-6">
                 <div className="flex items-center gap-2 opacity-60 bg-slate-900 px-3 py-1 rounded-full">
                    <div className="w-3 h-3 bg-stone-500 rounded-sm"></div>
                    <span className="text-red-400 font-bold">X</span>
                 </div>
                 <div className="flex items-center gap-2 opacity-80 bg-slate-900 px-3 py-1 rounded-full">
                    <div className="w-3 h-3 bg-cyan-400 rounded-sm"></div>
                    <span className="text-slate-500">+</span>
                    <Flame size={14} className="text-orange-500" />
                    <span className="text-emerald-400"><Check size={14}/></span>
                 </div>
            </div>
          </div>

          <div 
            className="bg-slate-800 p-4 rounded-3xl shadow-xl border border-slate-700 flex-1 flex flex-col min-h-[250px]"
          >
            <div className="flex justify-between items-center mb-4 px-2">
              <div className="flex items-center gap-3">
                <div className="bg-slate-700 p-2 rounded-lg text-slate-400">
                    <List size={20} />
                </div>
                <span className="bg-slate-900 text-slate-400 px-3 py-1 rounded-full text-sm font-bold border border-slate-700">
                    {program.length}
                </span>
              </div>
              <button 
                onClick={clearProgram}
                disabled={isPlaying || program.length === 0}
                className="text-slate-500 hover:text-red-400 hover:bg-slate-700 p-2 rounded-xl transition-all disabled:opacity-30"
              >
                <Trash2 size={24} />
              </button>
            </div>

            {/* Drop Container - Zde poslouch√°me drop na konci seznamu */}
            <div 
                className="flex-1 bg-slate-900/50 rounded-2xl p-4 border border-slate-700/50 overflow-y-auto content-start shadow-inner"
                onDragOver={handleDragOverEnd}
                onDrop={handleDrop}
            >
              <div className="flex flex-wrap gap-2">
                {program.length === 0 ? (
                  <div className="w-full h-32 flex flex-col items-center justify-center text-slate-600 opacity-40">
                    <div className="text-5xl mb-3 grayscale">üß©</div>
                  </div>
                ) : (
                  program.map((cmd, index) => {
                    const isBeingDragged = draggedItemIndex === index;
                    
                    return (
                    <React.Fragment key={cmd.id}>
                        {/* VIZU√ÅLN√ç DROP TARGET - INDIK√ÅTOR VLO≈ΩEN√ç */}
                        {dropTargetIndex === index && draggedItemIndex !== null && !isBeingDragged && (
                            <div className="w-14 h-14 rounded-xl border-2 border-dashed border-emerald-500/50 bg-emerald-500/10 flex-shrink-0 transition-all animate-pulse" />
                        )}

                        <div
                          draggable={!isPlaying}
                          onDragStart={(e) => handleDragStart(e, index)}
                          onDragEnd={handleDragEnd}
                          onDragOver={(e) => handleDragOver(e, index)}
                          onDrop={handleDrop}
                          className={`relative group transition-all duration-200
                              ${isBeingDragged ? 'opacity-20 scale-95' : 'opacity-100'}
                          `}
                        >
                            <button 
                              onClick={() => removeCommand(index)}
                              disabled={isPlaying}
                              className={`relative w-14 h-14 flex items-center justify-center rounded-xl border-2 shadow-sm transition-all
                                ${isPlaying ? 'cursor-default' : 'cursor-grab active:cursor-grabbing hover:scale-105 hover:z-10'}
                                ${index === currentStep 
                                  ? 'bg-yellow-500 border-yellow-300 scale-110 z-20 shadow-xl shadow-yellow-500/30' 
                                  : 'bg-slate-800 border-slate-600 hover:border-slate-400'
                                }
                              `}
                            >
                              {cmd.type === 'FORWARD' && <ArrowUp size={28} className={index === currentStep ? "text-white" : "text-blue-400"} />}
                              {cmd.type === 'LEFT' && <RotateCcw size={28} className={index === currentStep ? "text-white" : "text-purple-400"} />}
                              {cmd.type === 'RIGHT' && <RotateCw size={28} className={index === currentStep ? "text-white" : "text-purple-400"} />}
                              {cmd.type === 'MELT' && <Flame size={28} className={index === currentStep ? "text-white" : "text-orange-500"} />}
                              
                              <span className="absolute top-1 left-1.5 text-[10px] font-bold text-slate-500/50">
                                {index + 1}
                              </span>
                            </button>
                        </div>
                    </React.Fragment>
                  )})
                )}
                 {/* Drop target na konci seznamu */}
                 {program.length > 0 && dropTargetIndex === program.length && draggedItemIndex !== null && (
                      <div className="w-14 h-14 rounded-xl border-2 border-dashed border-slate-600 bg-slate-800/50 flex-shrink-0" />
                 )}
              </div>
            </div>

            <div className="mt-4">
              <button
                onClick={runProgram}
                disabled={isPlaying || program.length === 0}
                className={`w-full py-5 rounded-2xl font-bold text-xl flex items-center justify-center gap-3 shadow-xl transition-all transform active:scale-95
                  ${isPlaying 
                    ? 'bg-slate-700 text-slate-500 cursor-wait shadow-none' 
                    : 'bg-emerald-600 hover:bg-emerald-500 text-white shadow-emerald-900/40 hover:shadow-emerald-900/60'
                  }
                `}
              >
                {isPlaying ? (
                  <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-white"></div>
                ) : (
                  <>
                    <Play size={28} fill="currentColor" /> SPUSTIT
                  </>
                )}
              </button>
            </div>
          </div>

        </div>
      </main>
    </div>
  );
}