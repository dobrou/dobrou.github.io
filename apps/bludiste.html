<!--
PROMPT PRO REKREACI APLIKACE:

Vytvo콏te retro hru v HTML, CSS a JavaScriptu s n치sleduj칤c칤mi vlastnostmi:

Z치kladn칤 mechanika:
- Hr치캜 ovl치d치 t콏e코ni캜ku (游) v bludi코ti.
- C칤lem je naj칤t port치l (游) a postoupit do dal코칤ho levelu.
- V bludi코ti se pohybuj칤 nep콏치tel칠 (smajl칤ci), kte콏칤 hr치캜e pron치sleduj칤. Dotyk ub칤r치 쬴vot.

P콏edm캩ty a vylep코en칤:
- Lektvar (游빍): Po sebr치n칤 do캜asn캩 (na 10 sekund) odstran칤 v코echny pohybliv칠 nep콏치tele.
- Obvaz (游뽗): Dopln칤 jeden 쬴vot.
- Kl칤캜 (游댐): V ka쬯칠m levelu je jeden kl칤캜. Hr치캜 ho mus칤 sebrat, aby odemkl port치l (zm캩n칤 se z 游댖 na 游).
- Miska-past (游볶): V ka쬯칠m levelu je jedna. Pokud na ni hr치캜 stoupne, je na 1.5 sekundy znehybn캩n a blik치. Pot칠 je na 5 sekund imunn칤 v콢캜i t칠to pasti.
- 칔nikov칳 lektvar (游눤): Objev칤 se, kdy je hr치캜 uv캩zn캩n ve slep칠 uli캜ce. Po sebr치n칤 do캜asn캩 (na 6 sekund) otev콏e cestu v jedn칠 z okoln칤ch zd칤.

Hr치캜ovy schopnosti:
- Skok: Hr치캜 m콢쬰 sko캜it (mezern칤k/콘uknut칤 na displej), aby se vyhnul nep콏치tel콢m. Skok je deaktivov치n v posledn칤m levelu s bossy.

Hra pro v칤ce hr치캜콢 (kooperace):
- Re쬴m se aktivuje dynamicky, kdy se zapoj칤 dal코칤 hr치캜i.
- Hr치캜 2 (Jahoda 游꼡) se aktivuje stiskem WASD nebo na druh칠m gamepadu.
- Hr치캜 3 (Malina 游꼖) se aktivuje stiskem IJKL nebo na t콏et칤m gamepadu.
- Hr치캜i maj칤 spole캜n칳, nav칳코en칳 po캜et 쬴vot콢 (10 pro 2 hr치캜e, 15 pro 3 hr치캜e).
- Pro postup do dal코칤ho levelu mus칤 v코ichni hr치캜i st치t na port치lu sou캜asn캩.
- Nep콏치tel칠 v쬯y pron치sleduj칤 hr치캜e, kter칳 je k nim bl칤쬰.

Fin치ln칤 boss level (Level 17):
- Obsahuje 5 velk칳ch, 캜erven칳ch boss콢.
- Boss m치 rotuj칤c칤 lasery, kter칠 se zastav칤 o zdi a ub칤raj칤 쬴vot p콏i dotyku.
- Boss st콏칤l칤 projektily (游댠), kter칠 ub칤raj칤 2 쬴voty a ni캜칤 vnit콏n칤 zdi. St콏elba je m칠n캩 캜ast치 a postupn치.

Ovl치d치n칤:
- Kl치vesnice: Hr치캜 1 (코ipky + mezern칤k), Hr치캜 2 (WASD + lev칳 Shift), Hr치캜 3 (IJKL + prav칳 Shift).
- Gamepad: Pln치 podpora pro t콏i hr치캜e (pohyb D-Pad/p치캜kou, skok tla캜칤tkem A). Jak칳koliv gamepad m콢쬰 ovl치dat hr치캜e 1, pokud hraje s치m.
- Dotykov칠 ovl치d치n칤: Plynul칳 pohyb ta쬰n칤m prstu, skok kr치tk칳m 콘uknut칤m.

Ostatn칤:
- Celkem 17 level콢 s postupn캩 se zvy코uj칤c칤 obt칤쬹ost칤.
- 칔vodn칤 animace (Jaro, L칠to, Podzim, Zima), kterou lze p콏esko캜it stiskem libovoln칠 kl치vesy nebo kliknut칤m.
- Cheaty: 'LEVEL' + 캜칤slo/p칤smeno pro skok do levelu, 'KONEC' pro skok k fin치ln칤mu bossovi.
- Responzivn칤 design pro r콢zn치 za콏칤zen칤.
- UI zobrazuje 캜칤slo levelu a po캜et 쬴vot콢.
-->
<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bludi코t캩: 칔t캩k t콏e코n캩</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        canvas {
            background-color: #1a202c;
            border-radius: 0.5rem;
            box-shadow: 0 0 20px rgba(88, 101, 242, 0.5);
        }
        .pixel-font {
             font-family: 'Press Start 2P', cursive;
        }
        
        #canvas-wrapper {
            min-height: 0;
        }
        #gameCanvas {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
        }

        /* --- Intro Animation Styles --- */
        #intro-container {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            z-index: 50;
            background-color: black;
            transition: opacity 0.5s 1s;
        }
        #season-text {
            position: absolute;
            top: 10%;
            font-size: 3rem;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        #tree-trunk {
            position: absolute;
            bottom: 0;
            width: 40px;
            height: 0;
            background-color: #654321;
            transition: height 1.5s ease-out;
        }
        #tree-branch {
            position: absolute;
            bottom: 50%;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 20px;
            background-color: #654321;
            border-radius: 10px;
            transition: width 1.5s ease-out;
        }
        #fruit-container {
            position: absolute;
            bottom: calc(50% + 10px);
            left: 55%;
            font-size: 2.5rem;
            opacity: 0;
            transition: opacity 0.5s ease-in, transform 1.5s ease-in;
        }

    </style>
</head>
<body class="bg-gray-900 text-white items-center justify-center p-2 sm:p-4">
    
    <div id="intro-container">
        <div id="season-text"></div>
        <div id="tree-trunk"></div>
        <div id="tree-branch">
            <div id="fruit-container">
                <span id="fruit1">游</span>
                <span id="fruit2" style="display: none;">游꼡</span>
                <span id="fruit3" style="display: none;">游꼖</span>
            </div>
        </div>
    </div>

    <h1 class="text-2xl sm:text-3xl md:text-4xl mb-2 sm:mb-4 text-yellow-300 pixel-font flex-shrink-0">칔t캩k t콏e코n캩</h1>

    <div id="game-info" class="w-full max-w-full md:max-w-2xl lg:max-w-4xl flex justify-between items-center mb-2 sm:mb-4 text-base sm:text-lg md:text-xl pixel-font px-2 flex-shrink-0">
        <div>Level: <span id="level-display">1</span></div>
        <div>콯ivoty: <span id="lives-display">5</span></div>
    </div>
    
    <div id="canvas-wrapper" class="w-full flex-grow flex items-center justify-center">
         <canvas id="gameCanvas" class="border-4 border-indigo-500"></canvas>
    </div>


    <div id="message-modal" class="hidden absolute inset-0 bg-black bg-opacity-75 flex flex-col items-center justify-center text-center p-4">
        <h2 id="message-title" class="text-4xl md:text-6xl mb-4 pixel-font"></h2>
        <p id="message-text" class="text-xl mb-8 pixel-font"></p>
        <button id="restart-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg text-2xl pixel-font transition-transform transform hover:scale-105">
            Hr치t znovu
        </button>
    </div>

    <script>
        // --- Z치kladn칤 nastaven칤 hry ---
        var canvas = document.getElementById('gameCanvas');
        var ctx = canvas.getContext('2d');

        var levelDisplay = document.getElementById('level-display');
        var livesDisplay = document.getElementById('lives-display');
        var messageModal = document.getElementById('message-modal');
        var messageTitle = document.getElementById('message-title');
        var messageText = document.getElementById('message-text');
        var restartButton = document.getElementById('restart-button');

        var TILE_SIZE = 32;
        var gridSize;
        
        // --- Hern칤 stav ---
        var players = [];
        var enemies, portal, potion, bosses, projectiles, bandage, trapBowls, keys;
        var collectedKeys, totalKeys;
        var lives = 5;
        var currentLevel = 1;
        var maze = [];
        var isGameOver = false;
        var activePlayerCount = 1;
        
        var escapePotion = null;
        var openedWall = null;
        var escapePotionTimeout = null;
        var potionEffectActive = false;
        var potionEffectTimeout = null;

        var keysPressed = {};
        var cheatCodeBuffer = '';
        var lastPlayerMove = 0;
        var moveCooldown = 110;
        var introPlaying = true;
        var introTimeouts = [];


        // --- Definice level콢 ---
        var mazeLevels = [
            // Level 1
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,1,0,0,0,1,0,0,0,1],
                [1,0,1,0,1,0,1,0,0,1,1,0,1],
                [1,0,1,0,0,0,1,0,1,0,0,0,1],
                [1,0,1,1,1,1,1,1,1,0,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,1,0,1],
                [1,1,1,1,1,0,1,0,1,1,1,1,1],
                [1,0,0,0,1,0,1,0,0,0,0,0,1],
                [1,0,1,0,1,1,1,1,1,1,1,0,1],
                [1,0,1,0,0,0,0,0,0,0,1,0,1],
                [1,0,1,1,1,1,1,0,1,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            // Level 2
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,1,0,0,0,1,0,0,0,0,1],
                [1,0,1,1,0,1,0,1,0,1,0,1,1,0,1],
                [1,0,1,0,0,0,0,1,0,0,0,0,1,0,1],
                [1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],
                [1,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,0,1,0,1,1,1,0,1,1,1,1,1],
                [1,0,0,0,1,0,1,0,0,0,1,0,0,0,1],
                [1,0,1,1,1,0,1,0,1,1,1,0,1,1,1],
                [1,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
                [1,0,1,1,1,1,1,1,1,0,1,1,1,0,1],
                [1,0,1,0,0,0,0,0,1,0,0,0,0,0,1],
                [1,0,1,0,1,1,1,0,1,1,1,1,1,0,1],
                [1,0,0,0,0,0,1,0,0,0,0,0,1,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            // Level 3
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
                [1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],
                [1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1],
                [1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1],
                [1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1],
                [1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1],
                [1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1],
                [1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1],
                [1,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,1],
                [1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],
                [1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
                [1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1],
                [1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            // Level 3b size 15x15 only walls around and empty inside
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,1,1,1,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            ],
            // Level 4
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1],
                [1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1],
                [1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1],
                [1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1],
                [1,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,1],
                [1,0,1,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0,1],
                [1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1],
                [1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
                [1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
                [1,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1],
                [1,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1],
                [1,0,1,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0,1],
                [1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            // Level 5
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1],
                [1,0,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,0,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1],
                [1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1],
                [1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,1],
                [1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,1,0,0,1],
                [1,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1],
                [1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],
                [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,1],
                [1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1],
                [1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1],
                [1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1],
                [1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,0,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,0,1],
                [1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            // Level 6
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
                [1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1],
                [1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1],
                [1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1],
                [1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1],
                [1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1],
                [1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1],
                [1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1],
                [1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1],
                [1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,1],
                [1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1],
                [1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1],
                [1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1],
                [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1],
                [1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            // Level 7
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],
                [1,1,1,0,1,0,1,0,1,0,1,0,1,1,1],
                [1,0,0,0,1,0,1,0,1,0,1,0,0,0,1],
                [1,0,1,1,1,1,1,0,1,0,1,1,1,0,1],
                [1,0,0,0,0,0,0,0,1,0,0,0,1,0,1],
                [1,1,1,1,1,0,1,1,1,1,1,1,1,0,1],
                [1,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,0,1,1,1,1,1,0,1,1,1],
                [1,0,0,0,1,0,1,0,0,0,1,0,0,0,1],
                [1,1,1,0,1,0,1,0,1,0,1,0,1,1,1],
                [1,0,0,0,1,0,1,0,1,0,1,0,0,0,1],
                [1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],
                [1,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            // Level 8
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,1],
                [1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1],
                [1,0,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1],
                [1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1],
                [1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1],
                [1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,0,1],
                [1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1],
                [1,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1],
                [1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1],
                [1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,1,1],
                [1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1],
                [1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1],
                [1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1],
                [1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            // Level 9
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],
                [1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],
                [1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1],
                [1,1,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1],
                [1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
                [1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1],
                [1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
                [1,0,1,0,1,0,1,1,0,1,1,1,1,1,0,1,1,0,1],
                [1,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1],
                [1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1,1],
                [1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1],
                [1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1],
                [1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1],
                [1,0,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,0,1],
                [1,0,1,0,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1],
                [1,0,1,0,1,0,1,1,0,1,0,1,0,1,1,1,1,0,1],
                [1,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            // Level 10
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],
                [1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,1,1],
                [1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1],
                [1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1],
                [1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1],
                [1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1],
                [1,0,0,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1],
                [1,1,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1],
                [1,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1],
                [1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1],
                [1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1],
                [1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1],
                [1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1],
                [1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1],
                [1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1],
                [1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1],
                [1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],
                [1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],
                [1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            // Level 11
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
                [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
                [1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1],
                [1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1],
                [1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1],
                [1,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,1],
                [1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1],
                [1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1],
                [1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1],
                [1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1],
                [1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1],
                [1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1],
                [1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1],
                [1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1],
                [1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],
                [1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1],
                [1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            // Level 12
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1],
                [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1],
                [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1],
                [1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1],
                [1,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1],
                [1,0,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1],
                [1,0,1,1,1,1,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1],
                [1,0,1,0,0,0,0,0,1,0,1,1,1,0,1,0,1,0,1,0,1],
                [1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,0,1,0,0,0,1],
                [1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1],
                [1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,0,0,1,0,1],
                [1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1],
                [1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1],
                [1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
                [1,0,0,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1],
                [1,1,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1],
                [1,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1],
                [1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            // Level 13
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1],
                [1,0,1,0,1,0,1,1,0,1,0,1,0,1,1,1,0,1,1,0,1,0,1],
                [1,0,1,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,1,0,1],
                [1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,1,0,1],
                [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1],
                [1,1,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
                [1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1],
                [1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1],
                [1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1],
                [1,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1],
                [1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1],
                [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
                [1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1],
                [1,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,1],
                [1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,1,1],
                [1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1],
                [1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1],
                [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1],
                [1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            // Fin치ln칤 boss level
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1],
                [1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1],
                [1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1],
                [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
                [1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1],
                [1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1],
                [1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1],
                [1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1],
                [1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1],
                [1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1],
                [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
                [1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1],
                [1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1],
                [1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ]
        ];

        // --- Hern칤 objekty ---
        function GameObject(x, y, emoji) {
            this.x = x;
            this.y = y;
            this.emoji = emoji;
        }

        GameObject.prototype.draw = function() {
            if (!this.emoji) return;
            var drawSize = TILE_SIZE * 0.8;
            if (this.isJumping) {
                var jumpProgress = (Date.now() - this.jumpStartTime) / this.jumpDuration;
                var jumpHeight = Math.sin(jumpProgress * Math.PI); // Parabolick치 k콏ivka
                drawSize *= 1 + jumpHeight * 0.5; // Zv캩t코en칤 a o 50%
            }
            
            if(this.isTrapped && Math.floor(Date.now() / 150) % 2 === 0) {
                return; // Blik치n칤
            }

            ctx.font = drawSize + 'px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.emoji, this.x * TILE_SIZE + TILE_SIZE / 2, this.y * TILE_SIZE + TILE_SIZE / 2);
        }

        function Player(x, y) {
            GameObject.call(this, x, y, '游');
            this.isJumping = false;
            this.jumpDuration = 500; // ms
            this.jumpStartTime = 0;
            this.isTrapped = false;
            this.isTrapImmune = false;
        }
        Player.prototype = Object.create(GameObject.prototype);
        Player.prototype.constructor = Player;

        Player.prototype.jump = function() {
            if (this.isJumping || isGameOver || this.isTrapped || currentLevel === mazeLevels.length) return;
            this.isJumping = true;
            this.jumpStartTime = Date.now();
            var self = this;
            setTimeout(function() {
                self.isJumping = false;
            }, this.jumpDuration);
        }

        Player.prototype.move = function(dx, dy) {
            if (isGameOver || this.isJumping || this.isTrapped) return;
            var nextX = this.x + dx;
            var nextY = this.y + dy;
            if (!isWall(nextX, nextY)) {
                this.x = nextX;
                this.y = nextY;
            }
        }
        
        function TrapBowl(x, y) {
            GameObject.call(this, x, y, '游볶');
        }
        TrapBowl.prototype = Object.create(GameObject.prototype);
        TrapBowl.prototype.constructor = TrapBowl;

        function Projectile(x, y, dx, dy) {
            GameObject.call(this, x, y, '游댠');
            this.px = x * TILE_SIZE + TILE_SIZE / 2;
            this.py = y * TILE_SIZE + TILE_SIZE / 2;
            this.dx = dx;
            this.dy = dy;
            this.speed = 4;
        }
        Projectile.prototype = Object.create(GameObject.prototype);
        Projectile.prototype.constructor = Projectile;
        
        Projectile.prototype.update = function() {
            this.px += this.dx * this.speed;
            this.py += this.dy * this.speed;
            this.x = Math.floor(this.px / TILE_SIZE);
            this.y = Math.floor(this.py / TILE_SIZE);
        }
        
        Projectile.prototype.draw = function() {
            ctx.font = (TILE_SIZE * 0.7) + 'px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.emoji, this.px, this.py);
        }

        function Enemy(x, y) {
            GameObject.call(this, x, y, null);
            this.moveDelay = 350 - (currentLevel * 15);
            this.lastMove = Date.now();
            this.mouthOpen = false;
            this.lastMouthToggle = Date.now();
        }
        Enemy.prototype = Object.create(GameObject.prototype);
        Enemy.prototype.constructor = Enemy;

        Enemy.prototype.draw = function(sizeModifier) {
            sizeModifier = sizeModifier === undefined ? 1 : sizeModifier;
            if (Date.now() - this.lastMouthToggle > 300) {
                this.mouthOpen = !this.mouthOpen;
                this.lastMouthToggle = Date.now();
            }

            var currentTileSize = TILE_SIZE * sizeModifier;
            var centerX = this.x * TILE_SIZE + TILE_SIZE / 2;
            var centerY = this.y * TILE_SIZE + TILE_SIZE / 2;
            var radius = currentTileSize * 0.4;

            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(centerX - currentTileSize * 0.15, centerY - currentTileSize * 0.1, currentTileSize * 0.05, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(centerX + currentTileSize * 0.15, centerY - currentTileSize * 0.1, currentTileSize * 0.05, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2 * sizeModifier;
            ctx.beginPath();
            if (this.mouthOpen) {
                ctx.arc(centerX, centerY + currentTileSize * 0.05, radius * 0.5, 0.1 * Math.PI, 0.9 * Math.PI, false);
            } else {
                ctx.moveTo(centerX - radius * 0.3, centerY + currentTileSize * 0.15);
                ctx.lineTo(centerX + radius * 0.3, centerY + currentTileSize * 0.15);
            }
            ctx.stroke();
        }

        Enemy.prototype.move = function() {
            if (Date.now() - this.lastMove < this.moveDelay) return;
            this.lastMove = Date.now();

            var target = players[0];
            if (players.length > 1 && players[1]) {
                var dist1 = Math.sqrt(Math.pow(this.x - players[0].x, 2) + Math.pow(this.y - players[0].y, 2));
                var dist2 = Math.sqrt(Math.pow(this.x - players[1].x, 2) + Math.pow(this.y - players[1].y, 2));
                if (dist2 < dist1) {
                    target = players[1];
                }
            }

            var dx = Math.sign(target.x - this.x);
            var dy = Math.sign(target.y - this.y);
            
            if (Math.random() > 0.5) { 
                if (dx !== 0 && !isWall(this.x + dx, this.y)) { this.x += dx; }
                else if (dy !== 0 && !isWall(this.x, this.y + dy)) { this.y += dy; }
            } else {
                if (dy !== 0 && !isWall(this.x, this.y + dy)) { this.y += dy; }
                else if (dx !== 0 && !isWall(this.x + dx, this.y)) { this.x += dx; }
            }
        }
        
        function Boss(x, y, initialDelay) {
            Enemy.call(this, x, y);
            this.moveDelay = 800;
            this.shootCooldown = 4000;
            this.lastShot = Date.now() + initialDelay;
            this.lasers = [
                { angle: Math.random() * Math.PI * 2, length: TILE_SIZE * 4, speed: 0.02 },
                { angle: Math.random() * Math.PI * 2, length: TILE_SIZE * 4, speed: -0.02 }
            ];
        }
        Boss.prototype = Object.create(Enemy.prototype);
        Boss.prototype.constructor = Boss;
            
        Boss.prototype.updateLasers = function() {
            this.lasers.forEach(function(laser) {
                laser.angle += laser.speed;
            });
        }

        Boss.prototype.draw = function() {
            var centerX = this.x * TILE_SIZE + TILE_SIZE / 2;
            var centerY = this.y * TILE_SIZE + TILE_SIZE / 2;
            var radius = TILE_SIZE * 2.5 * 0.4;
            ctx.fillStyle = '#C70039';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();
            Enemy.prototype.draw.call(this, 2.5);
            this.drawLasers();
        }

        Boss.prototype.drawLasers = function() {
            var centerX = this.x * TILE_SIZE + TILE_SIZE / 2;
            var centerY = this.y * TILE_SIZE + TILE_SIZE / 2;

            this.lasers.forEach(function(laser) {
                var endX = centerX + Math.cos(laser.angle) * laser.length;
                var endY = centerY + Math.sin(laser.angle) * laser.length;

                // Raycasting to find the wall
                for (var i = 0; i < laser.length; i++) {
                    var checkX = centerX + Math.cos(laser.angle) * i;
                    var checkY = centerY + Math.sin(laser.angle) * i;
                    if (isWall(Math.floor(checkX / TILE_SIZE), Math.floor(checkY / TILE_SIZE))) {
                        endX = checkX;
                        endY = checkY;
                        break;
                    }
                }
                
                // Store the endpoint for collision detection
                laser.endX = endX;
                laser.endY = endY;
                
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.15)';
                ctx.lineWidth = 10;
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
                ctx.lineWidth = 5;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = '#ff6666';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
            
        Boss.prototype.shoot = function() {
            if (isGameOver || Date.now() - this.lastShot < this.shootCooldown) return;
            
            this.lastShot = Date.now();
            var target = players[Math.floor(Math.random() * players.length)];
            var dx = target.x - this.x;
            var dy = target.y - this.y;
            var distance = Math.sqrt(dx*dx + dy*dy);
            
            if (distance > 0) {
                var dirX = dx / distance;
                var dirY = dy / distance;
                projectiles.push(new Projectile(this.x, this.y, dirX, dirY));
            }
        }


        // --- Pomocn칠 funkce ---
        function isWall(x, y) {
            return !maze[y] || maze[y][x] === undefined || maze[y][x] === 1;
        }

        function isPlayerInDeadEnd(player) {
            if (isGameOver) return false;
            var x = player.x;
            var y = player.y;
            var neighbors = [{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }];
            var wallCount = 0;
            for (var i = 0; i < neighbors.length; i++) {
                var n = neighbors[i];
                if (isWall(x + n.dx, y + n.dy)) {
                    wallCount++;
                }
            }
            return wallCount >= 3;
        }

        function getRandomEmptyTile() {
            var emptyTiles = [];
            for (var y = 0; y < gridSize; y++) {
                for (var x = 0; x < gridSize; x++) {
                    if (maze[y][x] === 0) { emptyTiles.push({ x: x, y: y }); }
                }
            }
            return emptyTiles.length > 0 ? emptyTiles[Math.floor(Math.random() * emptyTiles.length)] : { x: 1, y: 1 };
        }
        
        function resetEnemyPositions() {
            enemies.forEach(function(enemy) {
                var pos;
                do {
                    pos = getRandomEmptyTile();
                } while (players.some(function(p) { return Math.abs(pos.x - p.x) < 5 && Math.abs(pos.y - p.y) < 5; }));
                enemy.x = pos.x;
                enemy.y = pos.y;
            });
        }

        function respawnPlayersAndPortal() {
            players.forEach(function(pl, index) {
                pl.x = 1;
                pl.y = 1 + index;
            });
            if (enemies.length > 0) {
                resetEnemyPositions();
            }
            var portalPos;
            do {
                portalPos = getRandomEmptyTile();
            } while (players.some(function(p) { return Math.abs(portalPos.x - p.x) < gridSize / 2 && Math.abs(portalPos.y - p.y) < gridSize / 2; }));
            portal.x = portalPos.x;
            portal.y = portalPos.y;
        }

        // --- Funkce pro inicializaci ---
        function initLevel() {
            isGameOver = false;
            var mazeData = mazeLevels[Math.min(currentLevel - 1, mazeLevels.length - 1)];
            maze = mazeData.map(function(row) { return row.slice(); });
            gridSize = maze.length;

            TILE_SIZE = Math.max(5, Math.floor(Math.min(window.innerWidth / gridSize, (window.innerHeight - 100) / gridSize)));
            canvas.width = gridSize * TILE_SIZE;
            canvas.height = gridSize * TILE_SIZE;

            players = [new Player(1, 1)];
            
            if (activePlayerCount >= 2) {
                players.push(new Player(1, 2));
                players[1].emoji = '游꼡';
            }
            if (activePlayerCount >= 3) {
                 players.push(new Player(1, 3));
                 players[2].emoji = '游꼖';
            }

            if (currentLevel === 1) {
                if (activePlayerCount === 3) lives = 15;
                else if (activePlayerCount === 2) lives = 10;
                else lives = 5;
            }
            
            enemies = [];
            bosses = [];
            projectiles = [];
            trapBowls = [];
            keys = [];
            collectedKeys = 0;
            
            clearTimeout(escapePotionTimeout);
            clearTimeout(potionEffectTimeout);
            escapePotion = null;
            openedWall = null;
            potionEffectActive = false;
            
            if (currentLevel === mazeLevels.length) {
                bosses.push(new Boss(gridSize - 2, gridSize - 2, 0));
                bosses.push(new Boss(1, gridSize - 2, 800));
                bosses.push(new Boss(gridSize - 2, 1, 1600));
                bosses.push(new Boss(Math.floor(gridSize/2), 1, 2400));
                bosses.push(new Boss(Math.floor(gridSize/2), gridSize - 2, 3200));
            } else {
                var enemyCount = Math.min(1 + Math.floor(currentLevel / 2), 3);
                for (var i = 0; i < enemyCount; i++) {
                    enemies.push(new Enemy(0, 0));
                }
                resetEnemyPositions();
            }

            var portalPos;
            do {
                portalPos = getRandomEmptyTile();
            } while (players.some(function(p) { return Math.abs(portalPos.x - p.x) < gridSize / 2 && Math.abs(portalPos.y - p.y) < gridSize / 2; }));
            portal = new GameObject(portalPos.x, portalPos.y, '游댖');
            portal.isLocked = true;
            
            potion = null;
            bandage = null;
            if (currentLevel < mazeLevels.length) {
                totalKeys = 1;
                for(var i = 0; i < totalKeys; i++) {
                    var keyPos;
                    do {
                       keyPos = getRandomEmptyTile();
                    } while (isWall(keyPos.x, keyPos.y));
                    keys.push(new GameObject(keyPos.x, keyPos.y, '游댐'));
                }

                var potionPos;
                 do {
                    potionPos = getRandomEmptyTile();
                } while ((potionPos.x === players[0].x && potionPos.y === players[0].y) || (potionPos.x === portal.x && potionPos.y === portal.y));
                potion = new GameObject(potionPos.x, potionPos.y, '游빍');

                var bandagePos;
                 do {
                    bandagePos = getRandomEmptyTile();
                } while ((bandagePos.x === players[0].x && bandagePos.y === players[0].y) || 
                         (bandagePos.x === portal.x && bandagePos.y === portal.y) ||
                         (potion && bandagePos.x === potion.x && bandagePos.y === potion.y));
                bandage = new GameObject(bandagePos.x, bandagePos.y, '游뽗');
                
                var trapPos;
                do {
                    trapPos = getRandomEmptyTile();
                } while(isWall(trapPos.x, trapPos.y));
                trapBowls.push(new TrapBowl(trapPos.x, trapPos.y));
            } else {
                portal.isLocked = false;
                portal.emoji = '游';
            }

            updateUI();
        }

        function updateUI() {
            levelDisplay.textContent = currentLevel;
            var maxLives = players.length === 3 ? 15 : (players.length === 2 ? 10 : 5);
            livesDisplay.textContent = "仇벒잺".repeat(lives) + "游둯".repeat(Math.max(0, maxLives - lives));
        }

        function restartGame() {
            messageModal.classList.add('hidden');
            activePlayerCount = 1;
            currentLevel = 1;
            initLevel();
        }

        function handleGamepadInput() {
            if (!navigator.getGamepads) return;
            var pads = navigator.getGamepads();
            
            // Dynamick치 aktivace hr치캜콢
            if (activePlayerCount < 2 && pads && pads[1]) {
                 var pad2 = pads[1];
                 if (pad2 && (pad2.buttons.some(function(b){return b.pressed;}) || pad2.axes.some(function(a){return Math.abs(a) > 0.5;}))) {
                    console.log(`Druh칳 gamepad aktivov치n. Restartuji pro 2 hr치캜e.`);
                    activePlayerCount = 2;
                    initLevel();
                    return;
                 }
            }
            if (activePlayerCount < 3 && pads && pads[2]) {
                var pad3 = pads[2];
                if (pad3 && (pad3.buttons.some(function(b){return b.pressed;}) || pad3.axes.some(function(a){return Math.abs(a) > 0.5;}))) {
                   console.log(`T콏et칤 gamepad aktivov치n. Restartuji pro 3 hr치캜e.`);
                   activePlayerCount = 3;
                   initLevel();
                   return;
                }
           }
            
            // Ovl치d치n칤 hr치캜콢
            for (var i = 0; i < players.length; i++) {
                if (pads[i] && players[i]) {
                    var pad = pads[i];
                    keysPressed['gp' + i + '_up'] = pad.axes[1] < -0.5 || pad.buttons[12].pressed;
                    keysPressed['gp' + i + '_down'] = pad.axes[1] > 0.5 || pad.buttons[13].pressed;
                    keysPressed['gp' + i + '_left'] = pad.axes[0] < -0.5 || pad.buttons[14].pressed;
                    keysPressed['gp' + i + '_right'] = pad.axes[0] > 0.5 || pad.buttons[15].pressed;
                    if (pad.buttons[0].pressed && !pad.buttons[0].lastPressed) {
                        players[i].jump();
                    }
                    pad.buttons[0].lastPressed = pad.buttons[0].pressed;
                }
            }
        }

        function gameLoop() {
            if (isGameOver) {
                if (navigator.getGamepads) {
                    var pads = navigator.getGamepads();
                    if (pads[0] && pads[0].buttons.some(function(b) { return b.pressed; })) {
                        restartGame();
                    }
                }
            } else {
                handleGamepadInput();
                update();
                draw();
            }
            requestAnimationFrame(gameLoop);
        }

        function update() {
            var now = Date.now();
            if (now - lastPlayerMove > moveCooldown) {
                var moved = false;
                if (keysPressed['arrowup'] || keysPressed['gp0_up']) { if(players[0]) players[0].move(0, -1); moved = true; } 
                else if (keysPressed['arrowdown'] || keysPressed['gp0_down']) { if(players[0]) players[0].move(0, 1); moved = true; } 
                else if (keysPressed['arrowleft'] || keysPressed['gp0_left']) { if(players[0]) players[0].move(-1, 0); moved = true; } 
                else if (keysPressed['arrowright'] || keysPressed['gp0_right']) { if(players[0]) players[0].move(1, 0); moved = true; }
                
                if (players.length > 1 && players[1]) {
                    if (keysPressed['w'] || keysPressed['gp1_up']) { players[1].move(0, -1); moved = true; } 
                    else if (keysPressed['s'] || keysPressed['gp1_down']) { players[1].move(0, 1); moved = true; } 
                    else if (keysPressed['a'] || keysPressed['gp1_left']) { players[1].move(-1, 0); moved = true; } 
                    else if (keysPressed['d'] || keysPressed['gp1_right']) { players[1].move(1, 0); moved = true; }
                }
                
                if (players.length > 2 && players[2]) {
                    if (keysPressed['i'] || keysPressed['gp2_up']) { players[2].move(0, -1); moved = true; } 
                    else if (keysPressed['k'] || keysPressed['gp2_down']) { players[2].move(0, 1); moved = true; } 
                    else if (keysPressed['j'] || keysPressed['gp2_left']) { players[2].move(-1, 0); moved = true; } 
                    else if (keysPressed['l'] || keysPressed['gp2_right']) { players[2].move(1, 0); moved = true; }
                }

                if (moved) lastPlayerMove = now;
            }

            if (!potionEffectActive) {
                enemies.forEach(function(enemy) { enemy.move(); });
            }
            bosses.forEach(function(b) {
                b.move();
                b.shoot();
                b.updateLasers();
            });

            for (var i = projectiles.length - 1; i >= 0; i--) {
                var p = projectiles[i];
                p.update();

                players.forEach(function(playerInstance) {
                     if (!playerInstance.isJumping && p.x === playerInstance.x && p.y === playerInstance.y) {
                        lives -= 2;
                        projectiles.splice(i, 1);
                        respawnPlayersAndPortal();
                        if (lives <= 0) { lives = 0; gameOver(false); }
                        updateUI();
                        return;
                    }
                });
                
                var gridX = p.x;
                var gridY = p.y;
                if (isWall(gridX, gridY)) {
                    if (gridX > 0 && gridX < gridSize - 1 && gridY > 0 && gridY < gridSize - 1) {
                        maze[gridY][gridX] = 0;
                    } else {
                        projectiles.splice(i, 1);
                    }
                }
            }
            
            players.forEach(function(p_instance) {
                if (isPlayerInDeadEnd(p_instance) && !p_instance.escapePotion && !openedWall) {
                    p_instance.escapePotion = new GameObject(p_instance.x, p_instance.y, '游눤');
                } else if (!isPlayerInDeadEnd(p_instance)) {
                    p_instance.escapePotion = null;
                }
            });

            var collisionDetected = false;
            players.forEach(function(p_instance) {
                if(collisionDetected) return;
                if (!p_instance.isJumping) {
                    var allMonsters = enemies.concat(bosses);
                    allMonsters.forEach(function(monster) {
                        if (!collisionDetected && monster.x === p_instance.x && monster.y === p_instance.y) {
                            collisionDetected = true;
                            lives--;
                            updateUI();
                            if (lives <= 0) { gameOver(false); }
                            else {
                               respawnPlayersAndPortal();
                            }
                        }
                    });

                    bosses.forEach(function(b) {
                        if(collisionDetected) return;
                        var bossCenterX = b.x * TILE_SIZE + TILE_SIZE / 2;
                        var bossCenterY = b.y * TILE_SIZE + TILE_SIZE / 2;
                        var playerCenterX = p_instance.x * TILE_SIZE + TILE_SIZE / 2;
                        var playerCenterY = p_instance.y * TILE_SIZE + TILE_SIZE / 2;
                        var playerRadius = TILE_SIZE * 0.4;

                        b.lasers.forEach(function(laser) {
                             if(collisionDetected) return;
                            var endX = laser.endX;
                            var endY = laser.endY;
                            
                            for (var i = 0.1; i <= 1; i += 0.1) {
                                var checkX = bossCenterX + (endX - bossCenterX) * i;
                                var checkY = bossCenterY + (endY - bossCenterY) * i;
                                var dist = Math.sqrt(Math.pow(playerCenterX - checkX, 2) + Math.pow(playerCenterY - checkY, 2));
                                if (dist < playerRadius) {
                                    collisionDetected = true;
                                    lives--;
                                    respawnPlayersAndPortal();
                                    if (lives <= 0) { lives = 0; gameOver(false); }
                                    updateUI();
                                    return;
                                }
                            }
                        });
                    });
                }
            });

            var allOnPortal = true;
            for(var i = 0; i < players.length; i++) {
                if(players[i].x !== portal.x || players[i].y !== portal.y) {
                    allOnPortal = false;
                    break;
                }
            }
            if (!portal.isLocked && allOnPortal) {
                nextLevel();
            }

            if (potion && players.some(function(p) { return p.x === potion.x && p.y === potion.y; })) {
                potion = null;
                potionEffectActive = true;
                var hiddenEnemies = enemies.slice();
                enemies = [];

                clearTimeout(potionEffectTimeout);
                potionEffectTimeout = setTimeout(function() {
                    enemies = hiddenEnemies;
                    resetEnemyPositions();
                    potionEffectActive = false;
                }, 10000);
            }

            if (bandage && players.some(function(p) { return p.x === bandage.x && p.y === bandage.y; })) {
                bandage = null;
                if (lives < (players.length > 1 ? 10 : 5)) { lives++; updateUI(); }
            }
            
            for (var i = keys.length - 1; i >= 0; i--) {
                var key = keys[i];
                if (players.some(function(p) { return p.x === key.x && p.y === key.y; })) {
                    keys.splice(i, 1);
                    collectedKeys++;
                    updateUI();
                    if (keys.length === 0) {
                        portal.isLocked = false;
                        portal.emoji = '游';
                    }
                }
            }

            players.forEach(function(p_instance) {
                if (p_instance.escapePotion && p_instance.x === p_instance.escapePotion.x && p_instance.y === p_instance.escapePotion.y) {
                    p_instance.escapePotion = null;
                    var x = p_instance.x;
                    var y = p_instance.y;
                    var wallNeighbors = [];
                    var neighbors = [{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }];
                    for (var n_idx = 0; n_idx < neighbors.length; n_idx++) {
                        var n = neighbors[n_idx];
                        var nx = x + n.dx; var ny = y + n.dy;
                        if (isWall(nx, ny) && nx > 0 && nx < gridSize - 1 && ny > 0 && ny < gridSize - 1) {
                            wallNeighbors.push({ x: nx, y: ny });
                        }
                    }
                    if (wallNeighbors.length > 0) {
                        var wallToOpen = wallNeighbors[Math.floor(Math.random() * wallNeighbors.length)];
                        openedWall = { x: wallToOpen.x, y: wallToOpen.y };
                        maze[openedWall.y][openedWall.x] = 0;
                        
                        clearTimeout(escapePotionTimeout);
                        escapePotionTimeout = setTimeout(function() {
                            if (openedWall) {
                                maze[openedWall.y][openedWall.x] = 1;
                                openedWall = null;
                            }
                        }, 6000);
                    }
                }

                trapBowls.forEach(function(trap) {
                    if(p_instance.x === trap.x && p_instance.y === trap.y && !p_instance.isTrapped && !p_instance.isTrapImmune){
                        p_instance.isTrapped = true;
                        setTimeout(function() {
                            p_instance.isTrapped = false;
                            p_instance.isTrapImmune = true;
                            setTimeout(function() {
                                p_instance.isTrapImmune = false;
                            }, 5000);
                        }, 1500);
                    }
                });
            });
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#1a202c';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (var y = 0; y < gridSize; y++) {
                for (var x = 0; x < gridSize; x++) {
                    if (isWall(x, y)) {
                        ctx.fillStyle = '#4a5568';
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
            portal.draw();
            if(potion) potion.draw();
            if(bandage) bandage.draw();
            players.forEach(function(p) { if(p.escapePotion) p.escapePotion.draw() });
            trapBowls.forEach(function(t) { t.draw(); });
            keys.forEach(function(k) { k.draw(); });
            players.forEach(function(p) { p.draw(); });
            enemies.forEach(function(enemy) { enemy.draw(); });
            bosses.forEach(function(b) { b.draw(); });
            projectiles.forEach(function(p) { p.draw(); });
        }

        function nextLevel() {
            currentLevel++;
            if (currentLevel > mazeLevels.length) {
                gameOver(true); 
            } else {
                initLevel();
            }
        }

        function gameOver(isWin) {
            isGameOver = true;
            if (isWin) {
                messageTitle.textContent = "V칗HRA!";
                messageText.textContent = "Dok치zali jste to a pro코li v코echna bludi코t캩!";
                messageTitle.style.color = '#48bb78';
            } else {
                messageTitle.textContent = "KONEC HRY";
                messageText.textContent = `Do코ly v치m 쬴voty. Zkuste to znovu!`;
                messageTitle.style.color = '#f56565';
            }
            messageModal.classList.remove('hidden');
        }

        function checkPlayerCount() {
            if (!navigator.getGamepads) return;
            var pads = navigator.getGamepads();
            var connectedPads = 0;
            for(var i = 0; i < pads.length; i++) {
                if(pads[i]) connectedPads++;
            }
            
            if (activePlayerCount < 2 && connectedPads >= 2) {
                 var pad2 = pads[1];
                 if (pad2 && (pad2.buttons.some(function(b){return b.pressed;}) || pad2.axes.some(function(a){return Math.abs(a) > 0.5;}))) {
                    console.log(`Druh칳 gamepad aktivov치n. Restartuji pro 2 hr치캜e.`);
                    activePlayerCount = 2;
                    initLevel();
                 }
            }
            if (activePlayerCount < 3 && connectedPads >= 3) {
                var pad3 = pads[2];
                if (pad3 && (pad3.buttons.some(function(b){return b.pressed;}) || pad3.axes.some(function(a){return Math.abs(a) > 0.5;}))) {
                   console.log(`T콏et칤 gamepad aktivov치n. Restartuji pro 3 hr치캜e.`);
                   activePlayerCount = 3;
                   initLevel();
                }
           }
        }

        // --- Ovl치d치n칤 ---
        window.addEventListener('keydown', function(e) {
            if (isGameOver) {
                if (e.code === 'Enter' || e.code === 'Space') {
                    restartGame();
                }
                return;
            }

            var key = e.key.toLowerCase();
            if (activePlayerCount < 2 && ['w','a','s','d'].indexOf(key) !== -1) {
                activePlayerCount = 2;
                initLevel();
                return;
            }
            if (activePlayerCount < 3 && ['i','j','k','l'].indexOf(key) !== -1) {
                activePlayerCount = 3;
                initLevel();
                return;
            }

            if (e.code === 'Space' && players[0]) players[0].jump();
            if (e.code === 'ShiftLeft' && players.length > 1 && players[1]) players[1].jump();
            if (e.code === 'ShiftRight' && players.length > 2 && players[2]) players[2].jump();
            
            keysPressed[key] = true;
            
            cheatCodeBuffer += e.key.toUpperCase();
            if (cheatCodeBuffer.length > 6) {
                cheatCodeBuffer = cheatCodeBuffer.slice(-6);
            }

            if (cheatCodeBuffer.endsWith('KONEC')) {
                 currentLevel = mazeLevels.length;
                 initLevel();
                 cheatCodeBuffer = '';
                 return;
            }

            if (cheatCodeBuffer.startsWith('LEVEL') && cheatCodeBuffer.length === 6) {
                var levelChar = cheatCodeBuffer.charAt(5);
                var levelNumber = -1;

                if (levelChar >= '1' && levelChar <= '9') {
                    levelNumber = parseInt(levelChar, 10);
                } else if (levelChar >= 'A' && levelChar <= 'Z') {
                    levelNumber = levelChar.charCodeAt(0) - 'A'.charCodeAt(0) + 10;
                }

                if (levelNumber > 0 && levelNumber <= mazeLevels.length) {
                    currentLevel = levelNumber;
                    initLevel();
                    cheatCodeBuffer = '';
                }
            }
        });
        
        window.addEventListener('keyup', function(e) {
            keysPressed[e.key.toLowerCase()] = false;
        });

        var touchStartX = 0, touchStartY = 0, touchStartTime = 0, touchMoved = false;
        
        window.addEventListener('touchstart', function(e) {
            if (messageModal.classList.contains('hidden')) {
                e.preventDefault();
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
                touchStartTime = Date.now();
                touchMoved = false;
            }
        }, { passive: false });
        
        window.addEventListener('touchmove', function(e) {
            if (messageModal.classList.contains('hidden')) {
                e.preventDefault();
                touchMoved = true;
                if (isGameOver) return;
                var touchEndX = e.changedTouches[0].screenX;
                var touchEndY = e.changedTouches[0].screenY;
                var dx = touchEndX - touchStartX;
                var dy = touchEndY - touchStartY;
                var threshold = 10;

                keysPressed['arrowup'] = keysPressed['arrowdown'] = keysPressed['arrowleft'] = keysPressed['arrowright'] = false;

                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > threshold) keysPressed['arrowright'] = true;
                    else if (dx < -threshold) keysPressed['arrowleft'] = true;
                } else {
                    if (dy > threshold) keysPressed['arrowdown'] = true;
                    else if (dy < -threshold) keysPressed['arrowup'] = true;
                }
            }
        }, { passive: false });

        window.addEventListener('touchend', function(e) {
            if (Date.now() - touchStartTime < 200 && !touchMoved) {
                if(players[0]) players[0].jump();
            }
             keysPressed['arrowup'] = keysPressed['arrowdown'] = keysPressed['arrowleft'] = keysPressed['arrowright'] = false;
        });

        window.addEventListener("gamepadconnected", checkPlayerCount);
        window.addEventListener("gamepaddisconnected", checkPlayerCount);

        restartButton.addEventListener('click', restartGame);
        
        window.addEventListener('resize', initLevel);
        
        function playIntroAnimation() {
            var introContainer = document.getElementById('intro-container');
            var seasonText = document.getElementById('season-text');
            var treeTrunk = document.getElementById('tree-trunk');
            var treeBranch = document.getElementById('tree-branch');
            var fruitContainer = document.getElementById('fruit-container');
            var fruit2 = document.getElementById('fruit2');
            var fruit3 = document.getElementById('fruit3');

            document.querySelector('h1').style.visibility = 'hidden';
            document.getElementById('game-info').style.visibility = 'hidden';
            document.getElementById('canvas-wrapper').style.visibility = 'hidden';

            if (activePlayerCount >= 2) {
                fruit2.style.display = 'inline';
            }
            if (activePlayerCount >= 3) {
                fruit3.style.display = 'inline';
            }

            var sequence = [
                { name: 'Jaro', color: '#87CEEB', duration: 1500, action: function() { treeTrunk.style.height = '50%'; } },
                { name: 'L칠to', color: '#228B22', duration: 1500, action: function() { treeBranch.style.width = '200px'; } },
                { name: 'Podzim', color: '#D2691E', duration: 1500, action: function() { fruitContainer.style.opacity = '1'; } },
                { name: 'Zima', color: '#ADD8E6', duration: 1500, action: function() { fruitContainer.style.transform = 'translateY(100vh)'; fruitContainer.style.opacity = '0';} }
            ];
            
            function skipIntro() {
                introTimeouts.forEach(function(timeoutId) { clearTimeout(timeoutId); });
                introContainer.style.opacity = '0';
                introContainer.style.pointerEvents = 'none';
                
                document.querySelector('h1').style.visibility = 'visible';
                document.getElementById('game-info').style.visibility = 'visible';
                document.getElementById('canvas-wrapper').style.visibility = 'visible';
                
                initLevel();
                gameLoop();
                window.removeEventListener('keydown', skipIntro);
                window.removeEventListener('click', skipIntro);
            }
            
            window.addEventListener('keydown', skipIntro);
            window.addEventListener('click', skipIntro);

            var delay = 500;
            sequence.forEach(function(season, index) {
                var timeout1 = setTimeout(function() {
                    seasonText.textContent = season.name;
                    introContainer.style.backgroundColor = season.color;
                    seasonText.style.opacity = '1';
                    
                    if(season.action) season.action();

                    var timeout2 = setTimeout(function() {
                        seasonText.style.opacity = '0';
                    }, season.duration - 500);
                    introTimeouts.push(timeout2);

                    if (index === sequence.length - 1) {
                         var timeout3 = setTimeout(function() {
                            skipIntro();
                        }, season.duration + 1500);
                        introTimeouts.push(timeout3);
                    }
                }, delay);
                introTimeouts.push(timeout1);
                delay += season.duration;
            });
        }

        // --- Start hry ---
        playIntroAnimation();
    </script>

</body>
</html>
