<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark background */
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            flex-direction: column;
        }

        .main-game-area {
            display: flex;
            flex-direction: row; /* Explicitly set to row for wider screens */
            gap: 30px; /* Reduced space between columns */
            justify-content: center;
            align-items: flex-start; /* Align items to the top */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            max-width: 100vw; /* Ensure it doesn't overflow */
            padding: 20px; /* Add some padding around the whole game area */
            box-sizing: border-box; /* Include padding in width calculation */
        }

        .player-board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2a2a4a;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            padding: 20px;
            gap: 15px;
            min-width: 340px; /* Min width for board + padding + border */
        }

        .player-board-container h2 {
            color: #9aff9a;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.8em;
        }

        canvas.game-canvas {
            background-color: #000; /* Game board background */
            border: 5px solid #4a4a8a; /* Border around the game board */
            border-radius: 10px;
            display: block;
            touch-action: none; /* Prevent default touch actions like scrolling */
        }

        .central-info-area {
            display: flex;
            flex-direction: column; /* Default to column for single player or small screens */
            gap: 20px; /* Space between info blocks */
            background-color: #2a2a4a;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            padding: 20px;
            min-width: 150px; /* Reduced minimum width for info area */
            align-items: center;
        }

        /* Styles for when there are two player info blocks side-by-side */
        .central-info-area.two-players {
            flex-direction: row; /* Arrange info blocks in a row */
            flex-wrap: wrap; /* Allow wrapping if space is tight */
            justify-content: space-around; /* Distribute space evenly */
            align-items: flex-start; /* Align to top within the row */
            gap: 10px; /* Smaller gap between info blocks when side-by-side */
        }

        .player-info-block {
            display: flex;
            flex-direction: column;
            gap: 8px; /* Slightly smaller gap within info block */
            width: 100%; /* Default to full width for single player/stacked */
            align-items: center;
        }

        /* Adjust width for player info blocks when in two-player mode */
        .central-info-area.two-players .player-info-block {
            width: calc(50% - 8px); /* Roughly half width minus gap */
            min-width: 120px; /* Further reduced min-width for individual player info */
        }


        .info-box {
            background-color: #3a3a6a;
            padding: 10px; /* Reduced padding */
            border-radius: 10px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
            width: 100%; /* Ensure info box takes full width */
            text-align: center;
            box-sizing: border-box; /* Include padding in width calculation */
        }

        .info-box h3 {
            margin-top: 0;
            margin-bottom: 8px; /* Adjusted margin */
            color: #9aff9a; /* Greenish title */
            font-size: 1em; /* Slightly smaller font for titles */
        }

        .info-box .value { /* Class for score/level values */
            font-size: 1.5em; /* Reduced font size for values */
            font-weight: bold;
            color: #ffcc00; /* Gold color for values */
        }

        canvas.next-piece-canvas {
            background-color: #000;
            border: 3px solid #4a4a8a;
            border-radius: 8px;
            margin-top: 10px;
        }

        #message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            text-align: center;
            z-index: 1000;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 20px;
            color: white;
            font-size: 1.5em;
            max-width: 80vw;
        }

        #message-box h2 {
            color: #ff6b6b; /* Reddish for game over */
            margin-bottom: 10px;
        }

        #message-box button {
            background-color: #4CAF50; /* Green for restart */
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.2em;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        #message-box button:hover {
            background-color: #45a049;
        }

        /* Responsive adjustments: Only stack elements on truly small screens */
        @media (max-width: 768px) {
            .main-game-area {
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }
            .player-board-container, .central-info-area {
                width: 90%; /* Take more width when stacked */
                max-width: 400px; /* Prevent stretching too wide */
                min-width: unset; /* Remove fixed min-width */
            }
            /* Ensure central info area stacks vertically on small screens */
            .central-info-area, .central-info-area.two-players {
                flex-direction: column;
                gap: 20px; /* Revert to larger gap when stacked */
            }
            .central-info-area.two-players .player-info-block {
                width: 100%; /* Take full width when stacked */
            }
        }

        @media (max-width: 480px) {
            .player-board-container, .central-info-area {
                width: 95%;
            }
        }
    </style>
</head>
<body>
    <div id="main-game-area" class="main-game-area">
        <!-- Player 1 Board -->
        <div id="player1-board-container" class="player-board-container">
            <h2>Player 1</h2>
            <canvas id="gameCanvas-0" class="game-canvas"></canvas>
        </div>

        <!-- Central Info Area -->
        <div id="central-info-area" class="central-info-area">
            <!-- Player 1 Info -->
            <div id="player1-info-block" class="player-info-block">
                <h3>Player 1 Stats</h3>
                <div class="info-box">
                    <h3>Score</h3>
                    <div id="score-0" class="value">0</div>
                </div>
                <div class="info-box">
                    <h3>Level</h3>
                    <div id="level-0" class="value">1</div>
                </div>
                <div class="info-box">
                    <h3>Next</h3>
                    <canvas id="next-piece-canvas-0" width="120" height="120" class="next-piece-canvas"></canvas>
                </div>
            </div>

            <!-- Player 2 Info (conditionally displayed) -->
            <div id="player2-info-block" class="player-info-block" style="display: none;">
                <h3>Player 2 Stats</h3>
                <div class="info-box">
                    <h3>Score</h3>
                    <div id="score-1" class="value">0</div>
                </div>
                <div class="info-box">
                    <h3>Level</h3>
                    <div id="level-1" class="value">1</div>
                </div>
                <div class="info-box">
                    <h3>Next</h3>
                    <canvas id="next-piece-canvas-1" width="120" height="120" class="next-piece-canvas"></canvas>
                </div>
            </div>
        </div>

        <!-- Player 2 Board (conditionally displayed) -->
        <div id="player2-board-container" class="player-board-container" style="display: none;">
            <h2>Player 2</h2>
            <canvas id="gameCanvas-1" class="game-canvas"></canvas>
        </div>
    </div>

    <div id="message-box">
        <h2 id="message-title"></h2>
        <p id="message-text"></p>
        <button id="restartButton">Play Again</button>
    </div>

    <script>
        // --- Game Setup ---
        const CANVAS_WIDTH = 300; // Standard Tetris width (10 blocks * 30px)
        const CANVAS_HEIGHT = 600; // Standard Tetris height (20 blocks * 30px)
        const BLOCK_SIZE = 30; // Size of each block in pixels
        const BOARD_WIDTH = 10; // Number of blocks wide
        const BOARD_HEIGHT = 20; // Number of blocks high

        const messageBox = document.getElementById('message-box');
        const messageTitle = document.getElementById('message-title');
        const messageText = document.getElementById('message-text');
        const restartButton = document.getElementById('restartButton');

        let gameInstances = []; // Global array to hold game instances
        const MAX_PLAYERS = 2; // Maximum number of players supported

        let wasdUsedForPlayer2 = false; // Global flag to track if WASD controls have been used for P2

        // Tetromino shapes and colors
        const TETROMINOES = {
            'I': {
                shape: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],
                color: '#00FFFF' // Cyan
            },
            'J': {
                shape: [[1, 0, 0], [1, 1, 1], [0, 0, 0]],
                color: '#0000FF' // Blue
            },
            'L': {
                shape: [[0, 0, 1], [1, 1, 1], [0, 0, 0]],
                color: '#FFA500' // Orange
            },
            'O': {
                shape: [[1, 1], [1, 1]],
                color: '#FFFF00' // Yellow
            },
            'S': {
                shape: [[0, 1, 1], [1, 1, 0], [0, 0, 0]],
                color: '#00FF00' // Green
            },
            'T': {
                shape: [[0, 1, 0], [1, 1, 1], [0, 0, 0]],
                color: '#800080' // Purple
            },
            'Z': {
                shape: [[1, 1, 0], [0, 1, 1], [0, 0, 0]],
                color: '#FF0000' // Red
            }
        };

        // Class to encapsulate game state for each player
        class GameState {
            // Constructor now takes direct references to the elements
            constructor(playerIndex, gameCanvasElement, nextPieceCanvasElement, scoreDisplayElement, levelDisplayElement) {
                this.playerIndex = playerIndex;
                this.gameCanvas = gameCanvasElement;
                this.ctx = this.gameCanvas.getContext('2d');
                this.nextPieceCanvas = nextPieceCanvasElement;
                this.nextCtx = this.nextPieceCanvas.getContext('2d');
                this.scoreDisplay = scoreDisplayElement;
                this.levelDisplay = levelDisplayElement;

                this.board = [];
                this.currentPiece = null;
                this.nextPiece = null;
                this.score = 0;
                this.level = 1;
                this.dropInterval = 1000; // Milliseconds per drop
                this.lastDropTime = 0;
                this.gameOver = false;
                console.log(`Player ${this.playerIndex + 1} GameState initialized.`);
            }

            // Function to draw a single block
            drawBlock(x, y, color, context) {
                context.fillStyle = color;
                context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                context.strokeStyle = '#333'; // Darker border for blocks
                context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            }

            // Function to initialize the game board
            initBoard() {
                this.board = Array(BOARD_HEIGHT).fill(0).map(() => Array(BOARD_WIDTH).fill(0));
                console.log(`Player ${this.playerIndex + 1} board initialized.`);
            }

            // Function to generate a random tetromino
            getRandomPiece() {
                const pieceKeys = Object.keys(TETROMINOES);
                const randomKey = pieceKeys[Math.floor(Math.random() * pieceKeys.length)];
                const pieceData = TETROMINOES[randomKey];
                console.log(`Player ${this.playerIndex + 1} generated new piece: ${randomKey}`);
                return {
                    shape: pieceData.shape,
                    color: pieceData.color,
                    x: Math.floor(BOARD_WIDTH / 2) - Math.floor(pieceData.shape[0].length / 2), // Center the piece
                    y: 0 // Start at the top
                };
            }

            // Function to draw the current piece
            drawPiece(piece, context, offsetX = 0, offsetY = 0) {
                // console.log(`Player ${this.playerIndex + 1} drawing piece at (${piece.x}, ${piece.y})`);
                piece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            this.drawBlock(piece.x + x + offsetX, piece.y + y + offsetY, piece.color, context);
                        }
                    });
                });
            }

            // Function to draw the entire board
            drawBoard() {
                // console.log(`Player ${this.playerIndex + 1} drawing board.`);
                this.board.forEach((row, y) => {
                    row.forEach((color, x) => {
                        if (color) {
                            this.drawBlock(x, y, color, this.ctx);
                        }
                    });
                });
            }

            // Check for collision
            checkCollision(piece, offsetX = 0, offsetY = 0) {
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x]) {
                            const boardX = piece.x + x + offsetX;
                            const boardY = piece.y + y + offsetY;

                            // Check boundaries
                            if (boardX < 0 || boardX >= BOARD_WIDTH || boardY >= BOARD_HEIGHT) {
                                // console.log(`Collision: Boundary at (${boardX}, ${boardY})`);
                                return true;
                            }
                            // Check if hitting an existing block (and not out of bounds at the top)
                            if (boardY >= 0 && boardY < BOARD_HEIGHT && this.board[boardY][boardX]) {
                                // console.log(`Collision: Existing block at (${boardX}, ${boardY})`);
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            // Merge current piece into the board
            mergePiece() {
                this.currentPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            this.board[this.currentPiece.y + y][this.currentPiece.x + x] = this.currentPiece.color;
                        }
                    });
                });
                console.log(`Player ${this.playerIndex + 1} piece merged.`);
            }

            // Clear full lines
            clearLines() {
                let linesCleared = 0;
                for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                    if (this.board[y].every(block => block !== 0)) {
                        // Line is full, remove it
                        this.board.splice(y, 1);
                        // Add a new empty row at the top
                        this.board.unshift(Array(BOARD_WIDTH).fill(0));
                        linesCleared++;
                        y++; // Re-check the same row index as rows shifted down
                    }
                }

                if (linesCleared > 0) {
                    const scores = [0, 100, 300, 500, 800];
                    this.score += scores[linesCleared] * this.level;
                    this.scoreDisplay.textContent = this.score;
                    console.log(`Player ${this.playerIndex + 1} cleared ${linesCleared} lines. New score: ${this.score}`);

                    if (this.score >= this.level * 1000) {
                        this.level++;
                        this.levelDisplay.textContent = this.level;
                        this.dropInterval = Math.max(50, this.dropInterval - 50);
                        console.log(`Player ${this.playerIndex + 1} leveled up to ${this.level}. New drop interval: ${this.dropInterval}`);
                    }
                }
            }

            // Rotate piece (clockwise)
            rotate() {
                console.log(`Player ${this.playerIndex + 1} attempting rotate.`);
                const numRows = this.currentPiece.shape.length;
                const numCols = this.currentPiece.shape[0].length;
                const newShape = Array(numCols).fill(0).map(() => Array(numRows).fill(0));

                for (let y = 0; y < numRows; y++) {
                    for (let x = 0; x < numCols; x++) {
                        newShape[x][numRows - 1 - y] = this.currentPiece.shape[y][x];
                    }
                }

                const originalShape = this.currentPiece.shape;
                this.currentPiece.shape = newShape;

                if (this.checkCollision(this.currentPiece)) {
                    let originalX = this.currentPiece.x;
                    let moved = false;
                    for (let i = 1; i <= 2; i++) {
                        this.currentPiece.x++;
                        if (!this.checkCollision(this.currentPiece)) {
                            moved = true;
                            break;
                        }
                    }
                    if (!moved) {
                        this.currentPiece.x = originalX;
                        for (let i = 1; i <= 2; i++) {
                            this.currentPiece.x--;
                            if (!this.checkCollision(this.currentPiece)) {
                                moved = true;
                                break;
                            }
                        }
                    }

                    if (!moved) {
                        this.currentPiece.x = originalX;
                        this.currentPiece.shape = originalShape;
                        console.log(`Player ${this.playerIndex + 1} rotation failed.`);
                    } else {
                        console.log(`Player ${this.playerIndex + 1} rotated and wall-kicked.`);
                    }
                } else {
                    console.log(`Player ${this.playerIndex + 1} rotated successfully.`);
                }
            }

            // Display Next Piece
            drawNextPiece() {
                this.nextCtx.clearRect(0, 0, this.nextPieceCanvas.width, this.nextPieceCanvas.height);
                const pieceWidth = this.nextPiece.shape[0].length;
                const pieceHeight = this.nextPiece.shape.length;
                const startX = (this.nextPieceCanvas.width / (BLOCK_SIZE * (window.devicePixelRatio || 1)) - pieceWidth) / 2;
                const startY = (this.nextPieceCanvas.height / (BLOCK_SIZE * (window.devicePixelRatio || 1)) - pieceHeight) / 2;
                this.drawPiece(this.nextPiece, this.nextCtx, startX, startY);
                console.log(`Player ${this.playerIndex + 1} next piece drawn.`);
            }

            // Move piece down (soft drop)
            softDrop() {
                // console.log(`Player ${this.playerIndex + 1} soft dropping. Current Y: ${this.currentPiece.y}`);
                this.currentPiece.y++;
                if (this.checkCollision(this.currentPiece)) {
                    this.currentPiece.y--;
                    this.mergePiece();
                    this.clearLines();
                    this.currentPiece = this.nextPiece;
                    this.nextPiece = this.getRandomPiece();
                    this.drawNextPiece();
                    if (this.checkCollision(this.currentPiece)) {
                        this.gameOver = true;
                        showMessage(`Player ${this.playerIndex + 1} Game Over!`, `Your score: ${this.score}`);
                        console.error(`Player ${this.playerIndex + 1} Game Over detected on new piece spawn.`);
                    }
                }
                this.lastDropTime = Date.now(); // Use Date.now()
            }

            // Hard drop
            hardDrop() {
                console.log(`Player ${this.playerIndex + 1} hard dropping.`);
                while (!this.checkCollision(this.currentPiece, 0, 1)) {
                    this.currentPiece.y++;
                }
                this.mergePiece();
                this.clearLines();
                this.currentPiece = this.nextPiece;
                this.nextPiece = this.getRandomPiece();
                this.drawNextPiece();
                if (this.checkCollision(this.currentPiece)) {
                    this.gameOver = true;
                    showMessage(`Player ${this.playerIndex + 1} Game Over!`, `Your score: ${this.score}`);
                    console.error(`Player ${this.playerIndex + 1} Game Over detected on hard drop.`);
                }
                this.lastDropTime = Date.now(); // Use Date.now()
            }

            // Move piece left
            moveLeft() {
                console.log(`Player ${this.playerIndex + 1} moving left.`);
                const originalX = this.currentPiece.x;
                this.currentPiece.x--;
                if (this.checkCollision(this.currentPiece)) {
                    this.currentPiece.x = originalX;
                    console.log(`Player ${this.playerIndex + 1} left move blocked.`);
                }
            }

            // Move piece right
            moveRight() {
                console.log(`Player ${this.playerIndex + 1} moving right.`);
                const originalX = this.currentPiece.x;
                this.currentPiece.x++;
                if (this.checkCollision(this.currentPiece)) {
                    this.currentPiece.x = originalX;
                    console.log(`Player ${this.playerIndex + 1} right move blocked.`);
                }
            }
        }

        // --- Game Loop ---
        let gameLoopTimeoutId = null; // Changed from animationFrameId to hold setTimeout ID

        function update() { // Removed time parameter as setTimeout doesn't provide it
            // console.log(`Update loop running.`);
            let allGamesOver = true;
            gameInstances.forEach(gameState => {
                if (gameState.gameOver) return;
                allGamesOver = false;

                const currentTime = Date.now(); // Use Date.now()
                const deltaTime = currentTime - gameState.lastDropTime;

                if (deltaTime > gameState.dropInterval) {
                    gameState.softDrop();
                }

                gameState.ctx.clearRect(0, 0, gameState.gameCanvas.width, gameState.gameCanvas.height);
                gameState.drawBoard();
                if (gameState.currentPiece) {
                    gameState.drawPiece(gameState.currentPiece, gameState.ctx);
                }
            });

            if (!allGamesOver) {
                gameLoopTimeoutId = setTimeout(update, 1000 / 60); // Aim for roughly 60 FPS, or adjust as needed
            } else {
                clearTimeout(gameLoopTimeoutId);
                gameLoopTimeoutId = null;
                console.log("All games over. Game loop stopped.");
            }
        }

        // --- Message Box ---
        function showMessage(title, text) {
            messageTitle.textContent = title;
            messageText.textContent = text;
            messageBox.style.display = 'flex';
            console.log(`Displaying message: ${title} - ${text}`);
        }

        function hideMessage() {
            messageBox.style.display = 'none';
            console.log("Hiding message box.");
        }

        // --- Gamepad Support ---
        let prevGamepadStates = {};

        function pollGamepads() {
            try {
                const currentPads = navigator.getGamepads ? navigator.getGamepads() : [];
                const connectedGamepadCount = currentPads.filter(g => g !== null).length;

                if (gameInstances.length === 1 && connectedGamepadCount >= 2) {
                    console.log("Late join detected via gamepad. Re-initializing games.");
                    initGames();
                    return;
                }

                for (let i = 0; i < currentPads.length && i < gameInstances.length; i++) {
                    const pad = currentPads[i];
                    if (pad && gameInstances[i] && !gameInstances[i].gameOver) {
                        if (!prevGamepadStates[i]) {
                            prevGamepadStates[i] = { buttons: pad.buttons.map(b => b.pressed) };
                            console.log(`Initialized prevGamepadStates for pad ${i}.`);
                        }

                        const gameState = gameInstances[i];

                        pad.buttons.forEach((button, buttonIndex) => {
                            if (button.pressed && !prevGamepadStates[i].buttons[buttonIndex]) {
                                console.log(`Gamepad ${i} button ${buttonIndex} pressed.`);
                                handleGamepadInput(gameState, buttonIndex);
                            }
                        });

                        prevGamepadStates[i].buttons = pad.buttons.map(b => b.pressed);

                        const axisThreshold = 0.5;
                        if (pad.axes[0] < -axisThreshold) { gameState.moveLeft(); }
                        else if (pad.axes[0] > axisThreshold) { gameState.moveRight(); }
                        if (pad.axes[1] > axisThreshold) { gameState.softDrop(); }
                    }
                }
            } catch (e) {
                console.error("Error in pollGamepads:", e);
            }
        }

        function handleGamepadInput(gameState, buttonIndex) {
            console.log(`Handling gamepad input for Player ${gameState.playerIndex + 1}, button: ${buttonIndex}`);
            switch (buttonIndex) {
                case 0: case 1: case 12: gameState.rotate(); break;
                case 13: gameState.softDrop(); break;
                case 14: gameState.moveLeft(); break;
                case 15: gameState.moveRight(); break;
                case 2: case 3: case 7: gameState.hardDrop(); break;
            }
        }

        // --- Keyboard Controls (for Player 1 and Player 2) ---
        document.addEventListener('keydown', e => {
            console.log(`Keydown event: ${e.key}`);
            // Player 1 controls (Arrow keys, Shift)
            if (gameInstances.length > 0 && !gameInstances[0].gameOver) {
                const player1GameState = gameInstances[0];
                switch (e.key) {
                    case 'ArrowLeft': player1GameState.moveLeft(); break;
                    case 'ArrowRight': player1GameState.moveRight(); break;
                    case 'ArrowDown': player1GameState.softDrop(); break;
                    case 'ArrowUp': case ' ': player1GameState.rotate(); break;
                    case 'Shift': player1GameState.hardDrop(); break;
                }
            }

            // Player 2 controls (WASD, Q)
            if (gameInstances.length === 1 && !wasdUsedForPlayer2) {
                const key = e.key.toLowerCase();
                if (['w', 'a', 's', 'd', 'q'].includes(key)) {
                    wasdUsedForPlayer2 = true;
                    console.log("Late join detected via WASD. Re-initializing games.");
                    initGames();
                    e.preventDefault();
                    return;
                }
            }

            if (gameInstances.length > 1 && !gameInstances[1].gameOver) {
                const player2GameState = gameInstances[1];
                switch (e.key.toLowerCase()) {
                    case 'a': player2GameState.moveLeft(); e.preventDefault(); break;
                    case 'd': player2GameState.moveRight(); e.preventDefault(); break;
                    case 's': player2GameState.softDrop(); e.preventDefault(); break;
                    case 'w': player2GameState.rotate(); e.preventDefault(); break;
                    case 'q': player2GameState.hardDrop(); e.preventDefault(); break;
                }
            }
        });

        restartButton.addEventListener('click', () => {
            console.log("Restart button clicked.");
            hideMessage();
            initGames();
        });

        // --- Initial Game Setup ---
        function initGames() {
            console.log("initGames called.");
            // Clear any existing timeout to prevent multiple loops running
            if (gameLoopTimeoutId) {
                clearTimeout(gameLoopTimeoutId);
                gameLoopTimeoutId = null;
                console.log("Cleared previous game loop timeout.");
            }

            const player1BoardContainer = document.getElementById('player1-board-container');
            const player2BoardContainer = document.getElementById('player2-board-container');
            const player1InfoBlock = document.getElementById('player1-info-block');
            const player2InfoBlock = document.getElementById('player2-info-block');
            const centralInfoArea = document.getElementById('central-info-area');

            const connectedGamepads = navigator.getGamepads ? Array.from(navigator.getGamepads()).filter(g => g !== null) : [];
            let desiredNumPlayers = Math.max(1, connectedGamepads.length);
            if (wasdUsedForPlayer2) {
                desiredNumPlayers = Math.max(desiredNumPlayers, 2);
            }
            desiredNumPlayers = Math.min(desiredNumPlayers, MAX_PLAYERS);
            console.log(`Desired number of players: ${desiredNumPlayers}`);

            if (desiredNumPlayers === 2) {
                player2BoardContainer.style.display = 'flex';
                player2InfoBlock.style.display = 'flex';
                centralInfoArea.classList.add('two-players');
                console.log("Displaying two-player UI.");
            } else {
                player2BoardContainer.style.display = 'none';
                player2InfoBlock.style.display = 'none';
                centralInfoArea.classList.remove('two-players');
                console.log("Displaying one-player UI.");
            }

            gameInstances = []; // Reset game instances

            // Initialize Player 1
            const gameCanvas0 = document.getElementById('gameCanvas-0');
            const nextPieceCanvas0 = document.getElementById('next-piece-canvas-0');
            const score0 = document.getElementById('score-0');
            const level0 = document.getElementById('level-0');
            gameInstances.push(new GameState(0, gameCanvas0, nextPieceCanvas0, score0, level0));
            console.log("Player 1 GameState added.");

            // Initialize Player 2 if needed
            if (desiredNumPlayers === 2) {
                const gameCanvas1 = document.getElementById('gameCanvas-1');
                const nextPieceCanvas1 = document.getElementById('next-piece-canvas-1');
                const score1 = document.getElementById('score-1');
                const level1 = document.getElementById('level-1');
                gameInstances.push(new GameState(1, gameCanvas1, nextPieceCanvas1, score1, level1));
                console.log("Player 2 GameState added.");
            }

            gameInstances.forEach(gameState => {
                gameState.initBoard();
                gameState.score = 0;
                gameState.level = 1;
                gameState.dropInterval = 1000;
                gameState.gameOver = false;
                gameState.scoreDisplay.textContent = gameState.score;
                gameState.levelDisplay.textContent = gameState.level;
                gameState.currentPiece = gameState.getRandomPiece();
                gameState.nextPiece = gameState.getRandomPiece();
                gameState.drawNextPiece();
                gameState.lastDropTime = Date.now(); // Use Date.now()
                console.log(`Player ${gameState.playerIndex + 1} game state reset.`);

                const dpr = window.devicePixelRatio || 1;
                gameState.gameCanvas.width = CANVAS_WIDTH * dpr;
                gameState.gameCanvas.height = CANVAS_HEIGHT * dpr;
                gameState.ctx.scale(dpr, dpr);
                gameState.gameCanvas.style.width = `${CANVAS_WIDTH}px`;
                gameState.gameCanvas.style.height = `${CANVAS_HEIGHT}px`;

                gameState.nextPieceCanvas.width = 120 * dpr;
                gameState.nextPieceCanvas.height = 120 * dpr;
                gameState.nextCtx.scale(dpr, dpr);
                gameState.nextPieceCanvas.style.width = '120px';
                gameState.nextPieceCanvas.style.height = '120px';
                console.log(`Player ${gameState.playerIndex + 1} canvas resized.`);
            });

            // Start the game loop using setTimeout
            if (!gameLoopTimeoutId) {
                gameLoopTimeoutId = setTimeout(update, 1000 / 60); // Aim for ~60 FPS
                console.log("Game loop started with setTimeout.");
            }

            wasdUsedForPlayer2 = false;
        }

        window.addEventListener("gamepadconnected", initGames);
        window.addEventListener("gamepaddisconnected", initGames);

        window.onload = function () {
            console.log("Window loaded. Starting game initialization.");
            initGames();
        };
    </script>
</body>
</html>
