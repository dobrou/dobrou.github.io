<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fotorealistické Skákající Míčky</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a202c; 
            touch-action: none; 
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 50%, #2d3748 0%, #1a202c 100%);
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none; 
            z-index: 10;
        }
        
        /* Animace pro plynulé skrytí UI */
        #ui-content {
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Třída, která se přidá při nečinnosti */
        .is-idle #ui-content {
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none !important;
        }
        
        .pointer-events-auto {
            pointer-events: auto;
        }

        /* Vlastní stylování posuvníku */
        input[type=range] {
            -webkit-appearance: none;
            width: 80px;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }
    </style>
</head>
<body>

    <!-- Vykreslovací plátno -->
    <canvas id="simulationCanvas"></canvas>

    <!-- Uživatelské rozhraní -->
    <div id="ui-layer" class="p-4 flex justify-center w-full">
        <!-- Kompaktní plovoucí lišta s ikonami -->
        <div id="ui-content" class="flex flex-wrap items-center gap-3 md:gap-6 bg-black/40 backdrop-blur-md px-6 py-3 rounded-full shadow-2xl pointer-events-auto border border-white/10">
            
            <!-- Posuvník velikosti -->
            <div class="flex items-center gap-2" title="Velikost přidávané kuličky">
                <svg class="w-5 h-5 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><circle cx="12" cy="12" r="8" stroke-width="2"/></svg>
                <input type="range" id="ballSize" min="10" max="80" value="30">
            </div>

            <!-- Dělící čára -->
            <div class="w-px h-6 bg-white/20 hidden sm:block"></div>
            
            <div class="flex items-center gap-2 sm:gap-4">
                <!-- Tlačítko Přidat -->
                <button id="btn-add" class="text-white hover:text-green-400 p-2 rounded-full transition-colors bg-white/5 hover:bg-white/10" title="Přidat kuličku (lze i pravým tlačítkem)">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/></svg>
                </button>

                <!-- Společné Tlačítko Režimu Gravitace (3 stavy) -->
                <button id="btn-gravity-mode" class="text-blue-400 p-2 rounded-full transition-colors bg-white/5 hover:bg-white/10" title="Gravitace: Dolů">
                    <svg id="icon-gravity-mode" class="w-6 h-6 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3"/></svg>
                </button>

                <!-- Tlačítko Fullscreen a Zámek rotace -->
                <button id="btn-fullscreen" class="text-white hover:text-yellow-400 p-2 rounded-full transition-colors bg-white/5 hover:bg-white/10" title="Celoobrazovkový režim (uzamkne rotaci na tabletech/mobilech)">
                    <svg id="icon-fullscreen" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"/></svg>
                </button>

                <!-- Tlačítko Vymazat -->
                <button id="btn-clear" class="text-white hover:text-red-400 p-2 rounded-full transition-colors bg-white/5 hover:bg-white/10" title="Vymazat všechny kuličky">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg>
                </button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');

        // Nastavení fyziky a gyroskopu
        let gravityMode = 'down'; // Možné stavy: 'down', 'gyro', 'none'
        let hasGyroSupport = typeof window.DeviceOrientationEvent !== 'undefined' && (/Mobi|Android/i.test(navigator.userAgent) || navigator.maxTouchPoints > 0);
        let useGyro = false;
        let baseGravity = 0.4;
        let gravityX = 0;
        let gravityY = baseGravity;
        const FRICTION_AIR = 0.998; 
        const RESTITUTION = 0.85; 

        let width, height;
        let balls = [];

        // Proměnné pro interakci (prak)
        let slingshotBall = null;
        let slingshotMousePos = { x: 0, y: 0 };
        
        // Proměnné pro detekci dvojkliku
        let lastClickTime = 0;
        let lastClickedBall = null;

        // UI elementy
        const sizeSlider = document.getElementById('ballSize');
        let idleTimeout;
        const uiLayer = document.getElementById('ui-layer');

        // Odhalení UI
        function wakeUI() {
            if (!uiLayer) return;
            uiLayer.classList.remove('is-idle');
            clearTimeout(idleTimeout);
            idleTimeout = setTimeout(() => {
                uiLayer.classList.add('is-idle');
            }, 2500);
        }

        // Změna velikosti plátna
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            wakeUI();
        }
        window.addEventListener('resize', resize);
        resize();

        // Třída reprezentující jeden míček
        class Ball {
            constructor(x, y, radius, hue) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 20;
                this.vy = (Math.random() - 0.5) * 20;
                this.radius = radius;
                this.mass = radius * radius;
                this.hue = hue;
            }

            draw(ctx) {
                if (!isFinite(this.x) || !isFinite(this.y) || !isFinite(this.radius) || this.radius <= 0) return;

                ctx.save();
                ctx.beginPath();
                const shadowX = this.x + this.radius * 0.15;
                const shadowY = this.y + this.radius * 0.15;
                const shadowRadius = this.radius * 1.3;
                
                let shadowGrad = ctx.createRadialGradient(shadowX, shadowY, 0, shadowX, shadowY, shadowRadius);
                shadowGrad.addColorStop(0, 'rgba(0, 0, 0, 0.4)');
                shadowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.arc(shadowX, shadowY, shadowRadius, 0, Math.PI * 2);
                ctx.fillStyle = shadowGrad;
                ctx.fill();
                ctx.restore();

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                
                const gradientX = this.x - this.radius * 0.3;
                const gradientY = this.y - this.radius * 0.3;
                let gradient = ctx.createRadialGradient(
                    gradientX, gradientY, Math.max(0.1, this.radius * 0.05), 
                    this.x, this.y, this.radius
                );
                
                gradient.addColorStop(0, `hsl(${this.hue}, 90%, 75%)`);
                gradient.addColorStop(0.4, `hsl(${this.hue}, 90%, 45%)`);
                gradient.addColorStop(1, `hsl(${this.hue}, 100%, 15%)`);
                
                ctx.fillStyle = gradient;
                ctx.fill();

                ctx.beginPath();
                const specRadius = this.radius * 0.35;
                const specX = this.x - this.radius * 0.4;
                const specY = this.y - this.radius * 0.4;
                
                ctx.arc(specX, specY, specRadius, 0, Math.PI * 2);
                let specGradient = ctx.createRadialGradient(
                    specX, specY, 0,
                    specX, specY, specRadius
                );
                specGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                specGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = specGradient;
                ctx.fill();
            }

            update() {
                if (slingshotBall === this) {
                    this.vx = 0;
                    this.vy = 0;
                    return;
                }

                if (gravityMode !== 'none') {
                    this.vx += gravityX;
                    this.vy += gravityY;
                }

                this.vx *= FRICTION_AIR;
                this.vy *= FRICTION_AIR;

                this.x += this.vx;
                this.y += this.vy;

                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx = -this.vx * RESTITUTION;
                    if (Math.abs(this.vx) < Math.abs(gravityX) * 1.5) this.vx = 0;
                } else if (this.x + this.radius > width) {
                    this.x = width - this.radius;
                    this.vx = -this.vx * RESTITUTION;
                    if (Math.abs(this.vx) < Math.abs(gravityX) * 1.5) this.vx = 0;
                }

                if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.vy = -this.vy * RESTITUTION;
                    if (Math.abs(this.vy) < Math.abs(gravityY) * 1.5) this.vy = 0;
                } else if (this.y + this.radius > height) {
                    this.y = height - this.radius;
                    this.vy = -this.vy * RESTITUTION;
                    if (Math.abs(this.vy) < Math.abs(gravityY) * 1.5) this.vy = 0;
                }
            }
        }

        function resolveCollisions() {
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    let b1 = balls[i];
                    let b2 = balls[j];

                    let dx = b2.x - b1.x;
                    let dy = b2.y - b1.y;
                    let distance = Math.hypot(dx, dy);

                    if (distance === 0) {
                        dx = 0.1;
                        dy = 0.1;
                        distance = Math.hypot(dx, dy);
                    }

                    let minDist = b1.radius + b2.radius;

                    if (distance < minDist) {
                        let penetration = minDist - distance;
                        let nx = dx / distance;
                        let ny = dy / distance;

                        let totalMass = b1.mass + b2.mass;
                        let m1Ratio = b2.mass / totalMass;
                        let m2Ratio = b1.mass / totalMass;

                        if (slingshotBall !== b1) {
                            b1.x -= nx * penetration * m1Ratio;
                            b1.y -= ny * penetration * m1Ratio;
                        }
                        if (slingshotBall !== b2) {
                            b2.x += nx * penetration * m2Ratio;
                            b2.y += ny * penetration * m2Ratio;
                        }

                        let dvx = b2.vx - b1.vx;
                        let dvy = b2.vy - b1.vy;
                        let velocityAlongNormal = dvx * nx + dvy * ny;

                        if (velocityAlongNormal > 0) continue;

                        let jFactor = -(1 + RESTITUTION) * velocityAlongNormal;
                        jFactor /= (1 / b1.mass) + (1 / b2.mass);

                        let impulseX = jFactor * nx;
                        let impulseY = jFactor * ny;

                        if (slingshotBall !== b1) {
                            b1.vx -= impulseX / b1.mass;
                            b1.vy -= impulseY / b1.mass;
                        }
                        if (slingshotBall !== b2) {
                            b2.vx += impulseX / b2.mass;
                            b2.vy += impulseY / b2.mass;
                        }
                    }
                }
            }
        }

        function addBall(x, y) {
            const radius = sizeSlider ? (parseInt(sizeSlider.value) || 30) : 30; 
            const hue = Math.floor(Math.random() * 360);
            balls.push(new Ball(x, y, radius, hue));
        }

        // --- Interakce myší a dotykem ---
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        function handleInputStart(x, y, button) {
            let hitBall = false;
            const currentTime = new Date().getTime();
            
            for (let i = balls.length - 1; i >= 0; i--) {
                let ball = balls[i];
                let dist = Math.hypot(ball.x - x, ball.y - y);
                if (dist <= ball.radius) {
                    hitBall = true;
                    
                    if (currentTime - lastClickTime < 300 && lastClickedBall === ball) {
                        balls.splice(i, 1);
                        slingshotBall = null;
                        lastClickedBall = null;
                        wakeUI();
                        return; 
                    }

                    slingshotBall = ball;
                    slingshotMousePos = { x, y };
                    lastClickedBall = ball;
                    break;
                }
            }
            
            lastClickTime = currentTime;
            
            if (!hitBall) {
                lastClickedBall = null;
                if (button === 2) addBall(x, y);
                wakeUI();
            }
        }

        function handleInputMove(x, y) {
            if (slingshotBall) {
                slingshotMousePos = { x, y };
            } else {
                wakeUI();
            }
        }

        function handleInputEnd(button) {
            if (button === 0 && slingshotBall) {
                let dx = slingshotBall.x - slingshotMousePos.x;
                let dy = slingshotBall.y - slingshotMousePos.y;
                slingshotBall.vx = dx * 0.15;
                slingshotBall.vy = dy * 0.15;
                slingshotBall = null;
            } else {
                wakeUI();
            }
        }

        canvas.addEventListener('mousedown', (e) => handleInputStart(e.clientX, e.clientY, e.button));
        window.addEventListener('mousemove', (e) => handleInputMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', (e) => handleInputEnd(e.button));

        canvas.addEventListener('touchstart', (e) => {
            if (e.target !== canvas) return;
            e.preventDefault();
            handleInputStart(e.touches[0].clientX, e.touches[0].clientY, 0);
        }, { passive: false });
        window.addEventListener('touchmove', (e) => {
            if (e.target !== canvas) return;
            e.preventDefault();
            handleInputMove(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });
        window.addEventListener('touchend', () => handleInputEnd(0));

        // --- Tlačítka UI ---
        const btnAdd = document.getElementById('btn-add');
        if (btnAdd) {
            btnAdd.addEventListener('click', () => {
                wakeUI();
                addBall(width / 2, height / 2);
            });
        }

        const btnClear = document.getElementById('btn-clear');
        if (btnClear) {
            btnClear.addEventListener('click', () => {
                wakeUI();
                balls = [];
            });
        }

        // --- Fullscreen a Zámek rotace ---
        const btnFullscreen = document.getElementById('btn-fullscreen');
        const iconFullscreen = document.getElementById('icon-fullscreen');

        if (btnFullscreen && iconFullscreen) {
            btnFullscreen.addEventListener('click', async () => {
                wakeUI();
                try {
                    if (!document.fullscreenElement) {
                        await document.documentElement.requestFullscreen();
                        if (screen.orientation && screen.orientation.lock) {
                            try {
                                await screen.orientation.lock(screen.orientation.type);
                            } catch (err) {
                                console.warn("Prohlížeč nebo zařízení nepodporuje uzamčení rotace.", err);
                            }
                        }
                        iconFullscreen.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 14h6m0 0v6m0-6l-7 7m17-11h-6m0 0V4m0 6l7-7M4 10h6m0 0V4m0 6l-7-7m17 11h-6m0 0v6m0-6l7 7"/>';
                    } else {
                        if (document.exitFullscreen) {
                            await document.exitFullscreen();
                        }
                        if (screen.orientation && screen.orientation.unlock) {
                            screen.orientation.unlock();
                        }
                        iconFullscreen.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"/>';
                    }
                } catch (err) {
                    console.error("Chyba při přepínání fullscreenu:", err);
                }
            });
        }

        // --- Sloučené ovládání Gyroskopu / Gravitace ---
        const btnGravityMode = document.getElementById('btn-gravity-mode');

        function updateGravityUI() {
            if (!btnGravityMode) return;
            if (gravityMode === 'down') {
                btnGravityMode.innerHTML = `<svg id="icon-gravity-mode" class="w-6 h-6 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3"/></svg>`;
                btnGravityMode.className = "text-blue-400 p-2 rounded-full transition-colors bg-white/5 hover:bg-white/10";
                btnGravityMode.title = "Gravitace: Dolů";
            } else if (gravityMode === 'gyro') {
                btnGravityMode.innerHTML = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><rect x="5" y="2" width="14" height="20" rx="2" stroke-width="2"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 18h.01"/></svg>`;
                btnGravityMode.className = "text-purple-400 p-2 rounded-full transition-colors bg-white/5 hover:bg-white/10";
                btnGravityMode.title = "Gravitace: Gyroskop";
            } else if (gravityMode === 'none') {
                btnGravityMode.innerHTML = `<svg id="icon-gravity-mode" class="w-6 h-6 transition-transform duration-300 rotate-180" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3"/></svg>`;
                btnGravityMode.className = "text-gray-500 p-2 rounded-full transition-colors bg-white/5 hover:bg-white/10";
                btnGravityMode.title = "Gravitace: Vypnuto";
            }
        }

        function handleOrientation(e) {
            if (!useGyro) return;
            let gamma = e.gamma; 
            let beta = e.beta;   

            if (gamma === null || beta === null) return;

            if (beta > 90) beta = 90;
            if (beta < -90) beta = -90;

            let angle = window.screen && window.screen.orientation ? window.screen.orientation.angle : window.orientation || 0;
            let maxG = 1.0; 

            if (angle === 90) {
                gravityX = (beta / 90) * maxG;
                gravityY = (-gamma / 90) * maxG;
            } else if (angle === -90 || angle === 270) {
                gravityX = (-beta / 90) * maxG;
                gravityY = (gamma / 90) * maxG;
            } else {
                gravityX = (gamma / 90) * maxG;
                gravityY = (beta / 90) * maxG;
            }
        }

        if (btnGravityMode) {
            btnGravityMode.addEventListener('click', async () => {
                wakeUI();
                // Určíme, jaké režimy jsou k dispozici podle podpory gyroskopu
                const modes = hasGyroSupport ? ['down', 'gyro', 'none'] : ['down', 'none'];
                let nextIndex = (modes.indexOf(gravityMode) + 1) % modes.length;
                let nextMode = modes[nextIndex];

                if (nextMode === 'gyro') {
                    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        try {
                            const permission = await DeviceOrientationEvent.requestPermission();
                            if (permission !== 'granted') {
                                hasGyroSupport = false; 
                                nextMode = 'none'; 
                            }
                        } catch (err) {
                            console.error(err);
                            hasGyroSupport = false;
                            nextMode = 'none';
                        }
                    }
                    if (nextMode === 'gyro') {
                        window.addEventListener('deviceorientation', handleOrientation);
                        useGyro = true;
                    }
                } 
                
                if (nextMode !== 'gyro') {
                    window.removeEventListener('deviceorientation', handleOrientation);
                    useGyro = false;
                    if (nextMode === 'down') {
                        gravityX = 0;
                        gravityY = baseGravity;
                    } else if (nextMode === 'none') {
                        gravityX = 0;
                        gravityY = 0;
                    }
                }

                gravityMode = nextMode;
                updateGravityUI();
            });
        }

        // --- Hlavní herní smyčka ---
        function animate() {
            ctx.clearRect(0, 0, width, height);

            balls.forEach(ball => ball.update());
            resolveCollisions();
            balls.forEach(ball => ball.draw(ctx));

            // Vykreslení gumičky praku
            if (slingshotBall) {
                ctx.beginPath();
                ctx.moveTo(slingshotBall.x, slingshotBall.y);
                ctx.lineTo(slingshotMousePos.x, slingshotMousePos.y);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 4;
                ctx.setLineDash([10, 10]); 
                ctx.stroke();
                ctx.setLineDash([]); 
            }

            // Vykreslení indikátoru gravitace
            drawGravityIndicator(ctx);

            requestAnimationFrame(animate);
        }

        // Nenápadný indikátor směru gravitace (vpravo dole)
        function drawGravityIndicator(ctx) {
            const cx = width - 35;
            const cy = height - 35;
            const r = 16;

            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 2;
            ctx.stroke();

            if (gravityMode !== 'none') {
                const mag = Math.hypot(gravityX, gravityY);
                if (mag > 0.01) {
                    const angle = Math.atan2(gravityY, gravityX);
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    
                    const ex = cx + Math.cos(angle) * r;
                    const ey = cy + Math.sin(angle) * r;
                    ctx.lineTo(ex, ey);
                    
                    ctx.lineTo(ex - Math.cos(angle - 0.4) * 6, ey - Math.sin(angle - 0.4) * 6);
                    ctx.moveTo(ex, ey);
                    ctx.lineTo(ex - Math.cos(angle + 0.4) * 6, ey - Math.sin(angle + 0.4) * 6);
                    
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.arc(cx, cy, 2, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.fill();
                }
            } else {
                ctx.beginPath();
                ctx.arc(cx, cy, 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.fill();
            }
            ctx.restore();
        }

        setTimeout(() => {
            for(let i=0; i<5; i++) {
                addBall(width * 0.2 + (width * 0.6 * Math.random()), height * 0.2 + (height * 0.4 * Math.random()));
            }
        }, 100);

        animate();

    </script>
</body>
</html>