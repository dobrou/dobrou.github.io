<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic-Tac-Toe</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --background-color: #121212;
            --cell-color: #1e1e1e;
            --border-color: #333333;
            --text-color: #ffffff;
            --accent-color: #4a4a4a;
            --x-color: #ffffff;
            --o-color: #bbbbbb;
            --disabled-opacity: 0.6;
            --gamepad-focus-color: #007bff;
        }

        /* Basic Reset and Body Styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow: hidden; /* Hide scrollbars that might appear from fireworks */
        }

        /* Main Game Container */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem; /* Adjusted gap */
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            margin: 0;
            font-weight: 700;
            letter-spacing: 2px;
        }

        /* Game Mode Selection */
        .mode-container {
            display: flex;
            justify-content: center;
            gap: 0.75rem; /* Reduced gap to fit */
        }

        .mode-button {
            background-color: transparent;
            color: var(--text-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 10px 12px; 
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            white-space: nowrap; /* Prevent text from wrapping */
        }

        .mode-button.active {
            background-color: var(--accent-color);
            border-color: var(--text-color);
        }

        .mode-button:not(.active):hover {
            background-color: var(--cell-color);
        }

        /* Game Board Styling */
        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            width: 320px;
            height: 320px;
            transition: opacity 0.3s ease;
        }
        
        /* Style for when the AI/Computer is thinking */
        .board.thinking {
            opacity: var(--disabled-opacity);
            pointer-events: none;
        }

        /* Cell Styling */
        .cell {
            background-color: var(--cell-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4rem;
            font-weight: bold;
            line-height: 1; /* Stabilize line height */
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
            -webkit-tap-highlight-color: transparent; /* Removes tap highlight on mobile */
        }
        
        .cell:hover {
            background-color: var(--accent-color);
        }

        .cell:focus {
            outline: none; /* Remove default focus outline, as we have a custom one */
        }
        
        /* Custom focus indicator for both keyboard and gamepad */
        .cell.focus-visible {
            border-color: var(--gamepad-focus-color);
            box-shadow: 0 0 10px var(--gamepad-focus-color);
        }
        
        .cell.X:hover, .cell.O:hover {
            background-color: var(--cell-color);
            cursor: not-allowed;
        }

        .cell.X { color: var(--x-color); }
        .cell.O { color: var(--o-color); }

        /* Status Display and Reset Button */
        .status-container {
            min-height: 3rem; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #status {
            font-size: 1.5rem;
            font-weight: 400;
        }
        
        .thinking-indicator {
            font-style: italic;
            color: var(--o-color);
        }

        #resetButton {
            background-color: var(--cell-color);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }
        
        #resetButton:hover {
            background-color: var(--accent-color);
            transform: translateY(-2px);
        }

        /* Winning animation */
        .winning-cell {
            background-color: #2c3e50 !important; 
            animation: pulse 0.8s infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        /* Fireworks Animation */
        .fireworks-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1000;
        }

        .particle {
            position: absolute;
            font-size: 1.5rem;
            font-weight: bold;
            opacity: 1;
        }

        @keyframes firework-explode {
            from {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            to {
                transform: translate(var(--translateX), var(--translateY)) scale(1.2);
                opacity: 0;
            }
        }

        /* Responsive Design */
        @media (max-width: 480px) {
            .board {
                width: 90vw;
                height: 90vw;
            }
            h1 { font-size: 2rem; }
            #status { font-size: 1.2rem; }
            .mode-container {
                gap: 0.5rem;
            }
            .mode-button {
                padding: 8px 10px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>

    <main class="game-container">
        <h1>Tic-Tac-Toe</h1>

        <div class="mode-container">
            <button id="pvpButton" class="mode-button active">vs Player</button>
            <button id="pvcButton" class="mode-button">vs Computer</button>
            <button id="pvaButton" class="mode-button">vs AI</button>
        </div>
        
        <div class="status-container">
            <p id="status">Player X's turn</p>
        </div>

        <div class="board" id="board" role="grid" aria-label="Tic-Tac-Toe Board">
            <!-- Cells are generated by JavaScript -->
        </div>

        <button id="resetButton">Reset Game</button>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const boardElement = document.getElementById('board');
            const statusElement = document.getElementById('status');
            const resetButton = document.getElementById('resetButton');
            const pvpButton = document.getElementById('pvpButton');
            const pvaButton = document.getElementById('pvaButton');
            const pvcButton = document.getElementById('pvcButton');

            // Game State
            let boardState = Array(9).fill('');
            let currentPlayer = 'X';
            let isGameActive = true;
            let cells = [];
            let gameMode = 'pvp'; // 'pvp', 'pva', or 'pvc'
            let isOpponentThinking = false;

            // Input State
            let gamepadIndex;
            let focusIndex = 0;
            let isFocusVisible = false; // FIX: Controls visibility of custom focus
            let lastInputTime = 0;
            const INPUT_COOLDOWN = 150; // ms

            const winningConditions = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
                [0, 4, 8], [2, 4, 6]             // Diagonals
            ];

            function initializeGame(newMode = gameMode) {
                gameMode = newMode;
                boardState.fill('');
                currentPlayer = 'X';
                isGameActive = true;
                isOpponentThinking = false;
                focusIndex = 0;
                isFocusVisible = false; // FIX: Reset focus visibility on new game

                boardElement.innerHTML = '';
                boardElement.classList.remove('thinking');
                cells = [];
                boardState.forEach((_, index) => {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.index = index;
                    cell.innerHTML = '&nbsp;'; 
                    cell.setAttribute('role', 'gridcell');
                    cell.setAttribute('aria-label', `Cell ${index + 1}`);
                    cell.setAttribute('tabindex', '0');
                    boardElement.appendChild(cell);
                    cells.push(cell);
                });
                updateFocus();
                updateStatus(`Player ${currentPlayer}'s turn`);
                updateModeButtons();
                addEventListeners();
            }
            
            function updateModeButtons() {
                pvpButton.classList.toggle('active', gameMode === 'pvp');
                pvaButton.classList.toggle('active', gameMode === 'pva');
                pvcButton.classList.toggle('active', gameMode === 'pvc');
            }

            function addEventListeners() {
                cells.forEach(cell => {
                    cell.addEventListener('click', handleCellClick);
                    cell.addEventListener('keydown', handleCellKeyDown);
                });
                resetButton.addEventListener('click', () => initializeGame());
                pvpButton.addEventListener('click', () => initializeGame('pvp'));
                pvaButton.addEventListener('click', () => initializeGame('pva'));
                pvcButton.addEventListener('click', () => initializeGame('pvc'));
            }

            function handleCellClick(event) {
                if (isOpponentThinking) return;
                const clickedCell = event.target;
                const cellIndex = parseInt(clickedCell.dataset.index);
                makeMove(cellIndex);
            }

            function handleCellKeyDown(event) {
                if (isOpponentThinking) return;
                const key = event.key;
                
                // Action keys
                if (key === 'Enter' || key === ' ') {
                    event.preventDefault();
                    makeMove(focusIndex); // Use the custom focus index
                    return;
                }

                if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) return;
                
                event.preventDefault();
                isFocusVisible = true; // FIX: Show focus on first keyboard navigation
                let newFocusIndex = focusIndex;

                switch (key) {
                    case 'ArrowUp':    newFocusIndex -= 3; break;
                    case 'ArrowDown':  newFocusIndex += 3; break;
                    case 'ArrowLeft':  if (focusIndex % 3 !== 0) newFocusIndex--; break;
                    case 'ArrowRight': if ((focusIndex + 1) % 3 !== 0) newFocusIndex++; break;
                }
                if (newFocusIndex >= 0 && newFocusIndex < 9) {
                    focusIndex = newFocusIndex;
                    updateFocus();
                }
            }
            
            function makeMove(cellIndex) {
                if (boardState[cellIndex] !== '' || !isGameActive) return;
                updateBoard(cellIndex);
                checkResult();
            }

            function updateBoard(index) {
                boardState[index] = currentPlayer;
                const cell = cells[index];
                cell.textContent = currentPlayer;
                cell.classList.add(currentPlayer);
                cell.style.cursor = 'not-allowed';
                cell.setAttribute('aria-label', `Cell ${index + 1} marked as ${currentPlayer}`);
                cell.removeAttribute('tabindex');
            }

            function checkResult() {
                const winner = checkWinner(boardState);

                if (winner) {
                    isGameActive = false;
                    updateStatus(`Player ${winner.player} has won!`);
                    highlightWinningCells(winner.combination);
                    launchFireworks(winner.player);
                    return;
                }

                if (!boardState.includes('')) {
                    isGameActive = false;
                    updateStatus('Game ended in a draw!');
                    return;
                }
                
                switchPlayer();
            }

            function checkWinner(board) {
                for (const winCondition of winningConditions) {
                    const [a, b, c] = winCondition;
                    if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                        return { player: board[a], combination: winCondition };
                    }
                }
                return null;
            }
            
            function switchPlayer() {
                currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                updateStatus(`Player ${currentPlayer}'s turn`);

                if (currentPlayer === 'O' && isGameActive) {
                    if (gameMode === 'pva') {
                        triggerAiMove();
                    } else if (gameMode === 'pvc') {
                        triggerComputerMove();
                    }
                }
            }
            
            function setOpponentThinking(isThinking) {
                isOpponentThinking = isThinking;
                boardElement.classList.toggle('thinking', isThinking);
                statusElement.classList.toggle('thinking-indicator', isThinking);
            }

            function triggerComputerMove() {
                setOpponentThinking(true);
                updateStatus('Computer is thinking...');
                
                setTimeout(() => {
                    const bestMove = findBestMove(boardState);
                    if (isGameActive) {
                        makeMove(bestMove.index);
                    }
                    setOpponentThinking(false);
                }, 500);
            }

            function triggerAiMove() {
                setOpponentThinking(true);
                updateStatus('AI is thinking...');

                setTimeout(async () => {
                    try {
                        const aiMove = await getAiMove();
                        if (isGameActive && boardState[aiMove] === '') {
                            makeMove(aiMove);
                        } else if (isGameActive) {
                            makeRandomMove();
                        }
                    } catch (error) {
                        console.error("Error getting AI move:", error);
                        updateStatus("AI failed. Making a random move.");
                        if(isGameActive) makeRandomMove();
                    } finally {
                        setOpponentThinking(false);
                    }
                }, 500);
            }

            // --- Gamepad and Keyboard Focus Control ---
            function setupGamepad() {
                window.addEventListener("gamepadconnected", (e) => {
                    gamepadIndex = e.gamepad.index;
                    updateStatus("Gamepad connected!");
                    setTimeout(() => updateStatus(`Player ${currentPlayer}'s turn`), 1500);
                    gamepadLoop();
                });

                window.addEventListener("gamepaddisconnected", () => {
                    gamepadIndex = undefined;
                    updateStatus("Gamepad disconnected.");
                });
            }

            function gamepadLoop() {
                if (gamepadIndex === undefined) return;
                
                const gamepad = navigator.getGamepads()[gamepadIndex];
                if (!gamepad) return;

                const now = Date.now();
                if (now - lastInputTime < INPUT_COOLDOWN) {
                    requestAnimationFrame(gamepadLoop);
                    return;
                }

                handleGamepadInput(gamepad);
                
                requestAnimationFrame(gamepadLoop);
            }
            
            function handleGamepadInput(gamepad) {
                const deadzone = 0.5;
                const dpadUp = gamepad.buttons[12].pressed;
                const dpadDown = gamepad.buttons[13].pressed;
                const dpadLeft = gamepad.buttons[14].pressed;
                const dpadRight = gamepad.buttons[15].pressed;
                const stickUp = gamepad.axes[1] < -deadzone;
                const stickDown = gamepad.axes[1] > deadzone;
                const stickLeft = gamepad.axes[0] < -deadzone;
                const stickRight = gamepad.axes[0] > deadzone;

                let moved = false;
                let newFocusIndex = focusIndex;

                if (dpadUp || stickUp) {
                    newFocusIndex -= 3;
                    moved = true;
                } else if (dpadDown || stickDown) {
                    newFocusIndex += 3;
                    moved = true;
                } else if (dpadLeft || stickLeft) {
                    if (focusIndex % 3 !== 0) newFocusIndex--;
                    moved = true;
                } else if (dpadRight || stickRight) {
                    if ((focusIndex + 1) % 3 !== 0) newFocusIndex++;
                    moved = true;
                }

                if (moved) {
                    isFocusVisible = true; // FIX: Show focus on first gamepad navigation
                    if (newFocusIndex >= 0 && newFocusIndex < 9) {
                        focusIndex = newFocusIndex;
                        updateFocus();
                    }
                    lastInputTime = Date.now();
                }

                if (gamepad.buttons[0].pressed) {
                    if (!isOpponentThinking) {
                        makeMove(focusIndex);
                    }
                    lastInputTime = Date.now();
                }
            }

            function updateFocus() {
                cells.forEach((cell, index) => {
                    // FIX: Use a single class and check visibility flag
                    cell.classList.toggle('focus-visible', isFocusVisible && index === focusIndex);
                });
            }


            // --- Minimax Algorithm for Player vs Computer ---
            function findBestMove(board) {
                let bestVal = -Infinity;
                let bestMove = { index: -1 };

                for (let i = 0; i < board.length; i++) {
                    if (board[i] === '') {
                        board[i] = 'O'; // Make a move
                        let moveVal = minimax(board, 0, false);
                        board[i] = ''; // Undo the move

                        if (moveVal > bestVal) {
                            bestMove.index = i;
                            bestVal = moveVal;
                        }
                    }
                }
                return bestMove;
            }

            function minimax(board, depth, isMaximizing) {
                const winner = checkWinner(board);
                if (winner) {
                    return winner.player === 'O' ? 10 - depth : -10 + depth;
                }
                if (!board.includes('')) {
                    return 0; // Draw
                }

                if (isMaximizing) {
                    let best = -Infinity;
                    for (let i = 0; i < board.length; i++) {
                        if (board[i] === '') {
                            board[i] = 'O';
                            best = Math.max(best, minimax(board, depth + 1, false));
                            board[i] = '';
                        }
                    }
                    return best;
                } else { // Minimizing player
                    let best = Infinity;
                    for (let i = 0; i < board.length; i++) {
                        if (board[i] === '') {
                            board[i] = 'X';
                            best = Math.min(best, minimax(board, depth + 1, true));
                            board[i] = '';
                        }
                    }
                    return best;
                }
            }
            
            async function getAiMove() {
                const availableIndices = boardState.map((val, idx) => val === '' ? idx : null).filter(val => val !== null);
                const prompt = `You are an expert Tic-Tac-Toe player. Your designated mark is 'O'. The user, playing as 'X', has just made a move. The game board is a 3x3 grid, with cells indexed from 0 to 8 (0=top-left, 8=bottom-right). The current board state is represented by this array (an empty string '' denotes an available cell): ${JSON.stringify(boardState)}. The available moves are at indices: ${JSON.stringify(availableIndices)}. Your task is to analyze the board and determine the single best move for 'O'. Your goal is to win, or if winning is not possible, to block the opponent from winning. Return your chosen move as a single number in a JSON object.`;
                const payload = {
                  contents: [{ role: "user", parts: [{ text: prompt }] }],
                  generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: { type: "OBJECT", properties: { "move": { "type": "NUMBER" } } }
                  }
                };
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`API call failed with status: ${response.status}`);
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content.parts.length > 0) {
                    const jsonText = result.candidates[0].content.parts[0].text;
                    const parsedJson = JSON.parse(jsonText);
                    return parsedJson.move;
                } else {
                    if (result.promptFeedback) console.error("Prompt Feedback:", result.promptFeedback);
                    throw new Error("Invalid response structure from API.");
                }
            }
            
            function makeRandomMove() {
                 if (!isGameActive) return;
                 const availableCells = boardState.map((val, idx) => val === '' ? idx : null).filter(val => val !== null);
                 if (availableCells.length > 0) {
                    const randomMove = availableCells[Math.floor(Math.random() * availableCells.length)];
                    makeMove(randomMove);
                 }
            }
            
            function updateStatus(message) {
                statusElement.textContent = message;
            }

            function highlightWinningCells(combination) {
                combination.forEach(index => cells[index].classList.add('winning-cell'));
            }

            function getRandomColor() {
                const hue = Math.floor(Math.random() * 360);
                return `hsl(${hue}, 100%, 75%)`;
            }

            function createBurst(container, winner) {
                const burstX = Math.random() * window.innerWidth;
                const burstY = Math.random() * window.innerHeight;
                const particleCount = 30;
                const explosionRadius = 150;

                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.textContent = winner;
                    particle.style.color = getRandomColor();
                    particle.style.left = `${burstX}px`;
                    particle.style.top = `${burstY}px`;
                    const angle = Math.random() * 2 * Math.PI;
                    const radius = Math.random() * explosionRadius;
                    const translateX = Math.cos(angle) * radius;
                    const translateY = Math.sin(angle) * radius;
                    particle.style.setProperty('--translateX', `${translateX}px`);
                    particle.style.setProperty('--translateY', `${translateY}px`);
                    const duration = 1000 + Math.random() * 500;
                    const delay = Math.random() * 200;
                    particle.style.animation = `firework-explode ${duration}ms ease-out ${delay}ms forwards`;
                    container.appendChild(particle);
                }
            }

            function launchFireworks(winner) {
                const container = document.createElement('div');
                container.className = 'fireworks-container';
                document.body.appendChild(container);
                const burstCount = 5;
                for (let i = 0; i < burstCount; i++) {
                    setTimeout(() => {
                        createBurst(container, winner);
                    }, i * 250);
                }
                setTimeout(() => {
                    if (document.body.contains(container)) {
                       document.body.removeChild(container);
                    }
                }, 3000);
            }

            // Start the game!
            initializeGame('pvp');
            setupGamepad();
        });
    </script>

</body>
</html>
