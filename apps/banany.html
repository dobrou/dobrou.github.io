<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√ötƒõk ban√°n≈Ø</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Press-Start-2P', cursive;
            background-color: #1a202c;
            color: #f7fafc;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
        canvas {
            border-radius: 0.5rem;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        .info-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 680px; /* Shodn√° se ≈°√≠≈ôkou pl√°tna */
            font-size: 1rem;
            padding: 0.5rem 1rem;
            background-color: #2d3748;
            border-radius: 0.5rem;
        }
        .modal {
            display: none; /* Skryto defaultnƒõ */
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #2d3748;
            padding: 2rem;
            border: 2px solid #4a5568;
            border-radius: 1rem;
            text-align: center;
            max-width: 90%;
            width: 500px;
        }
        .modal-content h2 {
            font-size: 1.75rem;
            margin-bottom: 1rem;
            color: #f7b733;
        }
        .modal-content p {
            font-size: 1rem;
            line-height: 1.5;
            margin-bottom: 1.5rem;
        }
        .modal-content button {
            background-color: #f7b733;
            color: #1a202c;
            border: none;
            padding: 0.75rem 1.5rem;
            font-family: 'Press Start 2P', cursive;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .modal-content button:hover {
            background-color: #fccb00;
        }
    </style>
</head>
<body>

<div class="game-container">
    <h1 class="text-3xl mb-4 text-yellow-400">√ötƒõk ban√°n≈Ø</h1>
    <div id="infoPanel" class="info-panel">
        <div id="livesInfo"></div>
        <div id="levelInfo"></div>
        <div id="enemiesInfo"></div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div class="text-sm mt-2">Ovl√°d√°n√≠: ≈†ipky/Gamepad | Mezern√≠k/Tlaƒç√≠tko A = Bomba</div>
</div>

<div id="messageModal" class="modal">
    <div class="modal-content">
        <h2 id="modalTitle"></h2>
        <p id="modalText"></p>
        <button id="modalButton"></button>
    </div>
</div>

<script>
    // --- Nastaven√≠ hry ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const TILE_SIZE = 40;
    const COLS = 17;
    const ROWS = 13;
    canvas.width = COLS * TILE_SIZE;
    canvas.height = ROWS * TILE_SIZE;

    // --- Hern√≠ stavy a objekty ---
    const TILES = { EMPTY: 0, INDESTRUCTIBLE: 1, DESTRUCTIBLE: 2 };
    let levelMap = [], bombs = [], explosions = [], enemies = [], powerUps = [];
    let player = {};
    let gameState = { currentLevel: 1, enemiesRemaining: 0, isPaused: false, killCount: 0 };
    let gamepads = {};
    let gamepadStates = {}; // Pro ulo≈æen√≠ stavu tlaƒç√≠tek ka≈æd√©ho gamepadu

    // --- Definice level≈Ø a bonus≈Ø ---
    const powerUpTypes = {
        range: { symbol: 'üî•', description: "Vƒõt≈°√≠ v√Ωbuch!" },
        extra_bomb: { symbol: 'üí£', description: "Bomba nav√≠c!" },
        walk_walls: { symbol: 'üí®', description: "M≈Ø≈æe≈° proch√°zet zdmi!" },
        walk_bombs: { symbol: 'üõ°Ô∏è', description: "M≈Ø≈æe≈° proch√°zet bombami!" },
        kick_bomb: { symbol: 'üëü', description: "M≈Ø≈æe≈° kopat do bomb!" },
    };

    const levelDesigns = {
        1: { name: "D≈æungle", bgColor: '#4CAF50', enemyType: 'üêµ', enemyName: "Opice", enemyCount: 3, wallType: 'üå≥', destructibleWallType: 'üåø', powerUps: ['range', 'extra_bomb'] },
        2: { name: "Hory", bgColor: '#a0d2eb', enemyType: 'üßä', enemyName: "Rampouchy", enemyCount: 4, wallType: '‚õ∞Ô∏è', destructibleWallType: '‚ùÑÔ∏è', powerUps: ['range', 'kick_bomb'] },
        3: { name: "Hrad - 1. patro", bgColor: '#6c757d', enemyType: 'üëª', enemyName: "Duchov√©", enemyCount: 5, wallType: 'üß±', destructibleWallType: 'üõ¢Ô∏è', powerUps: ['walk_walls', 'extra_bomb'] },
        4: { name: "Hrad - 2. patro", bgColor: '#495057', enemyType: 'üëª', enemyName: "Duchov√©", enemyCount: 6, wallType: 'üß±', destructibleWallType: 'üõ¢Ô∏è', powerUps: ['walk_bombs', 'range'] },
        5: { name: "Hrad - Tr≈Ønn√≠ s√°l" }
    };

    function resetPlayerStats() {
        player = {
            x: 1, y: 1,
            lives: 3,
            bombsMax: 1, bombRange: 1,
            isAlive: true,
            canWalkThroughWalls: false,
            canWalkThroughBombs: false,
            canKickBomb: false,
            isHit: false, hitTimer: 0,
            moveCooldown: 0, // Cooldown pro plynul√Ω pohyb
        };
        gameState.killCount = 0;
    }

    // --- Pomocn√© a UI funkce ---
    function getTile(x, y) {
        if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return TILES.INDESTRUCTIBLE;
        return levelMap[y][x];
    }
    
    function isBombAt(x, y) {
        return bombs.some(bomb => bomb.x === x && bomb.y === y);
    }

    function showModal(title, text, buttonText, onButtonClick) {
        gameState.isPaused = true;
        const modal = document.getElementById('messageModal');
        document.getElementById('modalTitle').innerText = title;
        document.getElementById('modalText').innerText = text;
        const button = document.getElementById('modalButton');
        button.innerText = buttonText;
        button.onclick = () => {
            modal.style.display = 'none';
            onButtonClick();
        };
        modal.style.display = 'flex';
    }

    function updateInfoPanel() {
        const levelData = levelDesigns[gameState.currentLevel];
        document.getElementById('livesInfo').innerText = `üçåx${player.lives}`;
        document.getElementById('levelInfo').innerText = `${levelData.name}`;
        document.getElementById('enemiesInfo').innerText = `${levelData.enemyName}: ${gameState.enemiesRemaining}`;
        canvas.style.backgroundColor = levelData.bgColor;
    }

    // --- Generov√°n√≠ levelu ---
    function generateLevel() {
        levelMap = Array.from({ length: ROWS }, () => Array(COLS).fill(TILES.EMPTY));
        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                if (y === 0 || y === ROWS - 1 || x === 0 || x === COLS - 1 || (y % 2 === 0 && x % 2 === 0)) {
                    levelMap[y][x] = TILES.INDESTRUCTIBLE;
                }
            }
        }
        let destructibleWalls = [];
        for (let y = 1; y < ROWS - 1; y++) {
            for (let x = 1; x < COLS - 1; x++) {
                if (levelMap[y][x] === TILES.EMPTY && (x > 2 || y > 2)) {
                     if(Math.random() > 0.2) {
                        levelMap[y][x] = TILES.DESTRUCTIBLE;
                        destructibleWalls.push({x, y});
                     }
                }
            }
        }
        
        const levelData = levelDesigns[gameState.currentLevel];
        if (levelData.powerUps) {
            levelData.powerUps.forEach(powerUpKey => {
                if (destructibleWalls.length > 0) {
                    const wallIndex = Math.floor(Math.random() * destructibleWalls.length);
                    const wall = destructibleWalls.splice(wallIndex, 1)[0];
                    const p = powerUpTypes[powerUpKey];
                    powerUps.push({x: wall.x, y: wall.y, type: powerUpKey, symbol: p.symbol});
                }
            });
        }
    }

    function spawnEntities() {
        const levelData = levelDesigns[gameState.currentLevel];
        gameState.enemiesRemaining = levelData.enemyCount;
        enemies = [];
        for (let i = 0; i < levelData.enemyCount; i++) {
            let placed = false;
            while (!placed) {
                const x = Math.floor(Math.random() * (COLS - 2)) + 1;
                const y = Math.floor(Math.random() * (ROWS - 2)) + 1;
                if (getTile(x, y) === TILES.EMPTY && (x > 5 || y > 5)) {
                    enemies.push({ x, y, type: levelData.enemyType, direction: {x:0, y:0}, moveCounter: 0 });
                    placed = true;
                }
            }
        }
    }

    function loadLevel(level) {
        gameState.isPaused = false;
        gameState.currentLevel = level;
        player.x = 1; player.y = 1;
        bombs = []; explosions = []; powerUps = [];
        generateLevel();
        spawnEntities();
        updateInfoPanel();
        gameLoop();
    }
    
    function startNewGame() {
        resetPlayerStats();
        loadLevel(1);
    }

    // --- Hern√≠ smyƒçka ---
    function gameLoop() {
        if (gameState.isPaused) return;
        handleGamepadInput();
        update();
        draw();
        if (!gameState.isPaused) {
            requestAnimationFrame(gameLoop);
        }
    }

    // --- Update logika ---
    function update() {
        if (!player.isAlive) return;
        
        if (player.moveCooldown > 0) player.moveCooldown--;
        
        if (player.isHit) {
            player.hitTimer--;
            if (player.hitTimer <= 0) player.isHit = false;
        }
        moveEnemies();
        updateBombs();
        checkCollisions();
    }
    
    function moveEnemies() {
        enemies.forEach(enemy => {
            enemy.moveCounter--;
            if (enemy.moveCounter <= 0) {
                const directions = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];
                enemy.direction = directions[Math.floor(Math.random() * directions.length)];
                enemy.moveCounter = Math.floor(Math.random() * 60) + 30;
            }
            const nextX = enemy.x + enemy.direction.x;
            const nextY = enemy.y + enemy.direction.y;
            if (getTile(nextX, nextY) === TILES.EMPTY && !isBombAt(nextX, nextY) && Math.random() < 0.02) {
                enemy.x = nextX;
                enemy.y = nextY;
            } else if (getTile(nextX, nextY) !== TILES.EMPTY || isBombAt(nextX, nextY)) {
                enemy.moveCounter = 0;
            }
        });
    }

    function updateBombs() {
        explosions = explosions.filter(e => --e.timer > 0);
        bombs.forEach(bomb => {
            if (bomb.isKicked) {
                bomb.kickTimer--;
                if (bomb.kickTimer <= 0) {
                    bomb.kickTimer = 8; // Rychlost klouz√°n√≠
                    const nextX = bomb.x + bomb.vx;
                    const nextY = bomb.y + bomb.vy;
                    if (getTile(nextX, nextY) === TILES.EMPTY && !isBombAt(nextX, nextY)) {
                        bomb.x = nextX;
                        bomb.y = nextY;
                    } else {
                        bomb.isKicked = false;
                    }
                }
            }
            bomb.timer--;
            if (bomb.timer <= 0 && !bomb.exploded) {
                triggerExplosion(bomb);
            }
        });
        bombs = bombs.filter(bomb => !bomb.exploded);
    }

    function triggerExplosion(bomb) {
        if (bomb.exploded) return;
        bomb.exploded = true;
        createExplosion(bomb.x, bomb.y, player.bombRange);
    }

    function createExplosion(x, y, range) {
        const explosionTiles = [{ x, y, timer: 20, type: 'center' }];
        const directions = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];
        directions.forEach(dir => {
            for (let i = 1; i <= range; i++) {
                const ex = x + dir.x * i;
                const ey = y + dir.y * i;
                const tile = getTile(ex, ey);
                if (tile === TILES.INDESTRUCTIBLE) break;
                
                const type = (i === range) ? 'end' : 'middle';
                explosionTiles.push({ x: ex, y: ey, timer: 20, dir: dir, type: type });
                
                bombs.forEach(b => { if(b.x === ex && b.y === ey) triggerExplosion(b); });

                if (tile === TILES.DESTRUCTIBLE) {
                    levelMap[ey][ex] = TILES.EMPTY;
                    break;
                }
            }
        });
        explosions.push(...explosionTiles);
    }

    function checkCollisions() {
        // Z√°sah hr√°ƒçe
        if (!player.isHit) {
            const currentEnemyName = levelDesigns[gameState.currentLevel].enemyName.slice(0, -1).toLowerCase();
            let hit = false;
            enemies.forEach(enemy => { if (enemy.x === player.x && enemy.y === player.y) hit = `Chytil tƒõ ${currentEnemyName}!`; });
            explosions.forEach(exp => { if (exp.x === player.x && exp.y === player.y) hit = "Zas√°hla tƒõ exploze!"; });
            if (hit) handlePlayerHit(hit);
        }

        // Z√°sah nep≈ô√°tel
        explosions.forEach(exp => {
            enemies = enemies.filter(enemy => {
                if (enemy.x === exp.x && enemy.y === exp.y) {
                    gameState.enemiesRemaining--;
                    gameState.killCount++;
                    if (gameState.killCount > 0 && gameState.killCount % 18 === 0) player.lives++;
                    updateInfoPanel();
                    return false;
                }
                return true;
            });
        });
        
        // Sebr√°n√≠ bonusu
        powerUps.forEach((powerUp, index) => {
            if(getTile(powerUp.x, powerUp.y) === TILES.EMPTY && player.x === powerUp.x && player.y === powerUp.y) {
                switch(powerUp.type) {
                    case 'range': player.bombRange++; break;
                    case 'extra_bomb': player.bombsMax++; break;
                    case 'walk_walls': player.canWalkThroughWalls = true; break;
                    case 'walk_bombs': player.canWalkThroughBombs = true; break;
                    case 'kick_bomb': player.canKickBomb = true; break;
                }
                powerUps.splice(index, 1);
            }
        });

        if (gameState.enemiesRemaining <= 0) levelComplete();
    }
    
    // --- Stavy hr√°ƒçe a postup ---
    function handlePlayerHit(reason) {
        player.lives--;
        player.isHit = true;
        player.hitTimer = 120; // 2s nesmrtelnost
        updateInfoPanel();
        if (player.lives <= 0) {
            gameOver(reason);
        } else {
            // Reset pozice
            player.x = 1;
            player.y = 1;
        }
    }

    function gameOver(reason) {
        player.isAlive = false;
        showModal("Konec hry!", reason, "Hr√°t znovu?", startNewGame);
    }

    function levelComplete() {
        gameState.isPaused = true;
        const nextLevel = gameState.currentLevel + 1;
        if (levelDesigns[nextLevel] && nextLevel < 5) {
            showModal("Level dokonƒçen!", "Poraƒè si s dal≈°√≠ v√Ωzvou.", "Dal≈°√≠ level", () => loadLevel(nextLevel));
        } else if (nextLevel === 5) {
            showModal("Level dokonƒçen!", "Postupuje≈° do tr≈Ønn√≠ho s√°lu!", "Vstoupit", () => showFinalScene());
        }
    }

    function showFinalScene() {
        gameState.isPaused = true;
        canvas.style.backgroundColor = '#2d3748';
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const dialogue = "Kr√°l ban√°n≈Ø üëë: 'V√≠tej, stateƒçn√Ω ban√°ne! Prok√°zal jsi velkou odvahu. Unikl jsi opic√≠m, zdolal hory a pro≈°el m√Ωm stra≈°ideln√Ωm hradem. Jsi hoden svobody!'";
        showModal("Setk√°n√≠ s kr√°lem", dialogue, "Hr√°t znovu?", startNewGame);
    }

    // --- Kreslen√≠ ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const levelData = levelDesigns[gameState.currentLevel];
        ctx.font = `${TILE_SIZE * 0.8}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) {
            const tile = getTile(x, y);
            let symbol = '';
            if (tile === TILES.INDESTRUCTIBLE) symbol = levelData.wallType;
            if (tile === TILES.DESTRUCTIBLE) symbol = levelData.destructibleWallType;
            if (symbol) ctx.fillText(symbol, x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
        }
        
        powerUps.forEach(p => {
            if(getTile(p.x, p.y) === TILES.EMPTY) ctx.fillText(p.symbol, p.x * TILE_SIZE + TILE_SIZE / 2, p.y * TILE_SIZE + TILE_SIZE / 2);
        });

        bombs.forEach(bomb => ctx.fillText('üí£', bomb.x * TILE_SIZE + TILE_SIZE / 2, bomb.y * TILE_SIZE + TILE_SIZE / 2));
        
        drawExplosions();

        if (player.isAlive) {
            ctx.globalAlpha = (player.isHit && Math.floor(player.hitTimer / 10) % 2 === 0) ? 0.5 : 1.0;
            ctx.fillText('üçå', player.x * TILE_SIZE + TILE_SIZE / 2, player.y * TILE_SIZE + TILE_SIZE / 2);
            ctx.globalAlpha = 1.0;
        }

        enemies.forEach(enemy => ctx.fillText(enemy.type, enemy.x * TILE_SIZE + TILE_SIZE / 2, enemy.y * TILE_SIZE + TILE_SIZE / 2));
    }

    function drawExplosions() {
        explosions.forEach(exp => {
            const centerX = exp.x * TILE_SIZE + TILE_SIZE / 2;
            const centerY = exp.y * TILE_SIZE + TILE_SIZE / 2;
            const progress = exp.timer / 20; // 1 -> 0

            const coreGrad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, TILE_SIZE / 2 * progress);
            coreGrad.addColorStop(0, 'white');
            coreGrad.addColorStop(0.5, 'yellow');
            coreGrad.addColorStop(1, 'rgba(255, 165, 0, 0.7)');
            ctx.fillStyle = coreGrad;
            ctx.beginPath();
            ctx.arc(centerX, centerY, TILE_SIZE / 2 * progress, 0, 2 * Math.PI);
            ctx.fill();
        });
    }

    // --- Ovl√°d√°n√≠ ---
    function placeBomb() {
        if (bombs.filter(b => !b.exploded).length < player.bombsMax && !isBombAt(player.x, player.y)) {
            bombs.push({ x: player.x, y: player.y, timer: 120, exploded: false, isKicked: false, vx: 0, vy: 0, kickTimer: 0 });
        }
    }

    function movePlayer(dx, dy) {
        if (!player.isAlive || gameState.isPaused) return;
        
        const newX = player.x + dx;
        const newY = player.y + dy;
        const targetTile = getTile(newX, newY);
        const bombAtTarget = bombs.find(b => b.x === newX && b.y === newY);

        if (player.canKickBomb && bombAtTarget && !bombAtTarget.isKicked) {
            bombAtTarget.isKicked = true;
            bombAtTarget.vx = dx;
            bombAtTarget.vy = dy;
            bombAtTarget.kickTimer = 8;
            return;
        }

        let canMove = false;
        if (targetTile === TILES.EMPTY || (targetTile === TILES.DESTRUCTIBLE && player.canWalkThroughWalls)) {
            canMove = true;
        }
        if (bombAtTarget && !player.canWalkThroughBombs) {
            canMove = false;
        }
        if (canMove) { player.x = newX; player.y = newY; }
    }

    window.addEventListener('keydown', (e) => {
        if (gameState.isPaused) return;
        e.preventDefault();
        switch (e.key) {
            case 'ArrowUp': movePlayer(0, -1); break;
            case 'ArrowDown': movePlayer(0, 1); break;
            case 'ArrowLeft': movePlayer(-1, 0); break;
            case 'ArrowRight': movePlayer(1, 0); break;
            case ' ': placeBomb(); break;
        }
    });

    // --- Gamepad API ---
    function handleGamepadInput() {
        if (!gamepads) return;

        for (const gamepad of Object.values(gamepads)) {
            if (!gamepad) continue;

            const state = gamepadStates[gamepad.index];

            // Tlaƒç√≠tko pro bombu (A)
            if (gamepad.buttons[0].pressed) {
                if (!state.buttonPressed) {
                    placeBomb();
                    state.buttonPressed = true;
                }
            } else {
                state.buttonPressed = false;
            }

            // Pohyb p√°ƒçkou
            if (player.moveCooldown > 0) continue;

            const deadzone = 0.4;
            const dx = gamepad.axes[0];
            const dy = gamepad.axes[1];
            
            if (Math.abs(dx) > deadzone || Math.abs(dy) > deadzone) {
                if (Math.abs(dx) > Math.abs(dy)) {
                    movePlayer(Math.sign(dx), 0);
                } else {
                    movePlayer(0, Math.sign(dy));
                }
                player.moveCooldown = 10; // Prodleva 10 sn√≠mk≈Ø pro plynul√Ω pohyb
            }
        }
    }

    window.addEventListener("gamepadconnected", (e) => {
        console.log("Gamepad p≈ôipojen:", e.gamepad.id);
        gamepads[e.gamepad.index] = e.gamepad;
        gamepadStates[e.gamepad.index] = { buttonPressed: false };
    });
    window.addEventListener("gamepaddisconnected", (e) => {
        console.log("Gamepad odpojen:", e.gamepad.id);
        delete gamepads[e.gamepad.index];
        delete gamepadStates[e.gamepad.index];
    });

    // --- Spu≈°tƒõn√≠ hry ---
    showModal("V√≠tej ve h≈ôe!", "Tv≈Øj √∫kol: Uteƒç z d≈æungle, p≈ôejdi hory a dosta≈à se z hradu. Zniƒç v≈°echny nep≈ô√°tele a sb√≠rej superschopnosti!", "Zaƒç√≠t hru", () => {
        startNewGame();
    });

</script>
</body>
</html>
