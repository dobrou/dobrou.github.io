<!DOCTYPE html>
<!--
    Popis programu:
    √ötƒõk ban√°n≈Ø je ark√°dov√° hra pro 1-4 hr√°ƒçe inspirovan√° klasikou Bomberman. Hr√°ƒçi ovl√°daj√≠ ovocn√©/zeleninov√© postaviƒçky, proch√°zej√≠ r≈Øzn√Ωmi prost≈ôed√≠mi (d≈æungle, hory, hrad), bojuj√≠ s nep≈ô√°teli a sb√≠raj√≠ bonusy. C√≠lem je p≈ôe≈æ√≠t, porazit fin√°ln√≠ho bosse a v tr≈Ønn√≠m s√°le slo≈æit puzzle pro osvobozen√≠ kr√°le ban√°n≈Ø. Hra podporuje kl√°vesnici, gamepady a dotykov√© ovl√°d√°n√≠ s dynamick√Ωm p≈ôipojen√≠m hr√°ƒç≈Ø.

    Historie p≈ô√≠kaz≈Ø a √∫prav:
    - Vytvo≈ôen√≠ z√°kladn√≠ho enginu hry: pohyb v m≈ô√≠≈æce, kladen√≠ bomb, niƒçen√≠ zd√≠.
    - Implementace z√°kladn√≠ch level≈Ø (D≈æungle, Hory, Hrad) a nep≈ô√°tel.
    - P≈ôid√°n√≠ superschopnost√≠ a bonus≈Ø (dosah plamene, poƒçet bomb, kop√°n√≠, proch√°zen√≠ zd√≠).
    - Implementace syst√©mu ≈æivot≈Ø a restartov√°n√≠ levelu po smrti.
    - P≈ôid√°n√≠ podpory pro Gamepady a dotykov√© ovl√°d√°n√≠ na mobiln√≠ch za≈ô√≠zen√≠ch.
    - Roz≈°√≠≈ôen√≠ pro v√≠ce hr√°ƒç≈Ø (Local Multiplayer 1-4 hr√°ƒçi).
    - Vizu√°ln√≠ rozli≈°en√≠ hr√°ƒç≈Ø (Ban√°n, Okurka, Mrkev, Lilek).
    - P≈ôepracov√°n√≠ UI: grafick√© ukazatele ≈æivot≈Ø a bonus≈Ø, odstranƒõn√≠ textov√Ωch ƒç√≠sel.
    - Optimalizace zobrazen√≠: maximalizace hern√≠ plochy, odstranƒõn√≠ okraj≈Ø a scrollov√°n√≠.
    - √öprava ovl√°d√°n√≠ dialog≈Ø: potvrzov√°n√≠ akƒçn√≠m tlaƒç√≠tkem (mezern√≠k/A).
    - Roz≈°√≠≈ôen√≠ obsahu: v√≠ce pater pro ka≈æd√© prost≈ôed√≠.
    - P≈ôid√°n√≠ fin√°ln√≠ho bosse (Kr√°l Opic) a nep≈ô√°telsk√© st√≠haƒçky s lasery.
    - Implementace "Boss Fight" mechanik: boss m√° ≈æivoty, st√≠haƒçka st≈ô√≠l√≠ jen p≈ôi p≈ô√≠m√©m v√Ωhledu.
    - P≈ôid√°n√≠ logick√©ho √∫kolu do posledn√≠ho levelu: posuvn√© puzzle s obrazem kr√°le.
    - Implementace mechaniky "Kl√≠ƒç a Port√°l": pro postup je nutn√© naj√≠t kl√≠ƒç a doj√≠t k port√°lu.
    - P≈ôid√°n√≠ "Speci√°ln√≠ bomby" (aktivace dvojstiskem/dvojklikem), kter√° niƒç√≠ i pevn√© zdi a m√° "splash" efekt.
    - P≈ôid√°n√≠ bonusu Nesmrtelnost (Hvƒõzda) na 10 sekund.
    - √öprava AI nep≈ô√°tel: ƒçastƒõj≈°√≠ pohyb, bezpeƒçnƒõj≈°√≠ spawn daleko od hr√°ƒç≈Ø.
    - Opravy chyb: zasek√°v√°n√≠ generov√°n√≠ mapy, p√°dy hry v boss levelu, oprava koliz√≠.
    - Zachov√°n√≠ trval√Ωch bonus≈Ø (plameny, bomby) p≈ôi p≈ôechodu do dal≈°√≠ho levelu.
-->
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>√ötƒõk ban√°n≈Ø</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Zamezit jak√©mukoliv scrollov√°n√≠ */
        }
        body {
            font-family: 'Press-Start-2P', cursive;
            background-color: #1a202c;
            color: #f7fafc;
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* Zarovnat nahoru */
            align-items: center;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
            padding: 4px; /* Minim√°ln√≠ padding */
            box-sizing: border-box;
        }
        .header-row {
            display: flex;
            width: 100%;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            flex-shrink: 0;
            background-color: #2d3748;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            min-height: 40px;
        }
        .canvas-wrapper {
            flex-grow: 1;
            width: 100%;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            margin-top: 4px;
        }
        canvas {
            border-radius: 0.25rem;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            image-rendering: pixelated;
            /* Canvas size is set by JS now */
        }
        .info-panel {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            flex-wrap: nowrap; /* Zabra≈à zalomen√≠ */
            gap: 0.5rem;
            flex-grow: 1;
            font-size: 0.6rem; /* Kompaktn√≠ p√≠smo */
            overflow-x: auto; /* Povolit horizont√°ln√≠ scroll v panelu, kdyby bylo moc hr√°ƒç≈Ø */
            scrollbar-width: none; /* Skr√Ωt scrollbar */
        }
        .player-info {
            display: flex;
            align-items: center;
            gap: 0.2rem;
            background-color: #4a5568;
            padding: 0.2rem 0.3rem;
            border-radius: 0.25rem;
            white-space: nowrap;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #2d3748;
            padding: 2rem;
            border: 2px solid #4a5568;
            border-radius: 1rem;
            text-align: center;
            max-width: 90%;
            width: 500px;
        }
        .modal-content h2 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: #f7b733;
        }
        .modal-content p {
            font-size: 0.9rem;
            line-height: 1.5;
            margin-bottom: 1.5rem;
        }
        .modal-content button {
            background-color: #f7b733;
            color: #1a202c;
            border: none;
            padding: 0.75rem 1.5rem;
            font-family: 'Press Start 2P', cursive;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.3s;
            margin: 0.5rem;
        }
        .modal-content button:hover {
            background-color: #fccb00;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        .special-bomb {
            animation: pulse 1s infinite;
        }
    </style>
</head>
<body>

<div class="game-container">
    <div id="headerRow" class="header-row">
        <h1 class="text-xs md:text-sm text-yellow-400 m-0 whitespace-nowrap">√ötƒõk ban√°n≈Ø</h1>
        <div id="infoPanel" class="info-panel"></div>
    </div>
    <div class="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
    </div>
</div>

<div id="messageModal" class="modal">
    <div class="modal-content">
        <h2 id="modalTitle"></h2>
        <p id="modalText"></p>
        <button id="modalButton"></button>
    </div>
</div>

<script>
    // --- Nastaven√≠ hry ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // TILE_SIZE je nyn√≠ dynamick√° promƒõnn√°
    let TILE_SIZE = 40;
    const COLS = 17;
    const ROWS = 13;

    function resizeGame() {
        const header = document.getElementById('headerRow');
        const containerPadding = 8; // 4px padding top/bottom from .game-container
        
        const availableWidth = window.innerWidth - containerPadding;
        const availableHeight = window.innerHeight - header.offsetHeight - containerPadding;
        
        // Vypoƒç√≠tat maxim√°ln√≠ velikost dla≈ædice, aby se ve≈°la cel√° m≈ô√≠≈æka
        const maxTileWidth = Math.floor(availableWidth / COLS);
        const maxTileHeight = Math.floor(availableHeight / ROWS);
        
        TILE_SIZE = Math.min(maxTileWidth, maxTileHeight);
        
        // Nastavit velikost pl√°tna
        canvas.width = COLS * TILE_SIZE;
        canvas.height = ROWS * TILE_SIZE;
        
        // P≈ôekreslit, pokud hra bƒõ≈æ√≠
        if (gameState && !gameState.isPaused) {
            draw();
        } else if (gameState && gameState.isPaused) {
            draw(); // P≈ôekreslit i p≈ôi pauze (pro zobrazen√≠ pozad√≠)
        }
    }

    window.addEventListener('resize', resizeGame);

    // --- Hern√≠ stavy a objekty ---
    const TILES = { EMPTY: 0, INDESTRUCTIBLE: 1, DESTRUCTIBLE: 2 };
    let levelMap = [], bombs = [], explosions = [], enemies = [], powerUps = [], projectiles = [];
    let players = [];
    let boss = null;
    let fighterJet = null;
    let gameState = { 
        currentLevel: 1, 
        enemiesRemaining: 0, 
        isPaused: false, 
        killCount: 0, 
        gameActive: false, 
        inputCooldown: 0, 
        kingArrived: false,
        portal: { x: -1, y: -1 },
        keyFound: false
    };
    let puzzle = { grid: [], solvedGrid: [], emptyTile: {x:0, y:0}, size: 3, offsetX: 0, offsetY: 0 };

    const PLAYER_CONFIG = [
        { id: 'keyboard1', symbol: 'ü•ï', start: { x: COLS - 2, y: 1 }, controls: { type: 'keyboard', up: 'arrowup', down: 'arrowdown', left: 'arrowleft', right: 'arrowright', bomb: ' ' } },
        { id: 'keyboard2', symbol: 'ü•í', start: { x: COLS - 2, y: ROWS - 2 }, controls: { type: 'keyboard', up: 'w', down: 's', left: 'a', right: 'd', bomb: 'q' } },
        { id: 'gamepad0', symbol: 'üçå', start: { x: 1, y: 1 }, controls: { type: 'gamepad' } },
        { id: 'gamepad1', symbol: 'üçÜ', start: { x: 1, y: ROWS - 2 }, controls: { type: 'gamepad' } }
    ];
    let keysPressed = {};
    let cheatBuffer = "";
    
    const powerUpTypes = {
        range: { symbol: 'üî•', weight: 4 }, // Vy≈°≈°√≠ v√°ha pro ƒçastƒõj≈°√≠ v√Ωskyt
        extra_bomb: { symbol: 'üí£', weight: 4 },
        walk_walls: { symbol: 'üí®', weight: 1 },
        walk_bombs: { symbol: 'üõ°Ô∏è', weight: 1 },
        kick_bomb: { symbol: 'üëü', weight: 1 },
        speed: { symbol: 'üèÉ', weight: 1},
        extra_life: { symbol: '‚ù§Ô∏è', weight: 0.5 },
        wall_destroyer: { symbol: 'üí•', weight: 1 },
        key: { symbol: 'üîë', weight: 0 }, // Kl√≠ƒç se generuje zvl√°≈°≈•
        invincibility: { symbol: '‚≠ê', weight: 0.5 } // Vz√°cn√° nesmrtelnost
    };
    // Vytvo≈ô√≠me pole kl√≠ƒç≈Ø s v√°≈æenou pravdƒõpodobnost√≠
    const weightedPowerUps = [];
    Object.keys(powerUpTypes).forEach(key => {
        if (key !== 'key') {
            for(let i=0; i<powerUpTypes[key].weight * 2; i++) {
                weightedPowerUps.push(key);
            }
        }
    });

    const levelDesigns = {
        1: { name: "D≈æungle I", bgColor: '#4CAF50', enemyType: 'üêµ', enemyName: "Opice", enemyCount: 3, wallType: 'üå≥', destructibleWallType: 'üåø' },
        2: { name: "D≈æungle II", bgColor: '#388E3C', enemyType: 'üêç', enemyName: "Hadi", enemyCount: 4, wallType: 'üå≥', destructibleWallType: 'üåø' },
        3: { name: "Hory I", bgColor: '#a0d2eb', enemyType: 'üßä', enemyName: "Rampouchy", enemyCount: 4, wallType: '‚õ∞Ô∏è', destructibleWallType: '‚ùÑÔ∏è' },
        4: { name: "Hory II", bgColor: '#81c7e8', enemyType: 'üßä', enemyName: "Rampouchy", enemyCount: 5, wallType: '‚õ∞Ô∏è', destructibleWallType: '‚ùÑÔ∏è' },
        5: { name: "Hrad - 1. patro", bgColor: '#6c757d', enemyType: 'üëª', enemyName: "Duchov√©", enemyCount: 5, wallType: 'üß±', destructibleWallType: 'üõ¢Ô∏è' },
        6: { name: "Hrad - 2. patro", bgColor: '#495057', enemyType: 'üëª', enemyName: "Duchov√©", enemyCount: 6, wallType: 'üß±', destructibleWallType: 'üõ¢Ô∏è' },
        7: { name: "Hrad - 3. patro", bgColor: '#343a40', enemyType: 'üëª', enemyName: "Duchov√©", enemyCount: 7, wallType: 'üß±', destructibleWallType: 'üõ¢Ô∏è' },
        8: { name: "Ar√©na Kr√°le Opic", bgColor: '#d32f2f', enemyType: '', enemyName: "Kr√°l Opic", enemyCount: 1, wallType: 'üß±', destructibleWallType: 'üõ¢Ô∏è', isBossLevel: true },
        9: { name: "Hrad - Tr≈Ønn√≠ s√°l", bgColor: '#212121', enemyCount: 0, isFinalLevel: true, goalTiles: [{x:3, y:3}, {x:13, y:3}, {x:3, y:9}, {x:13, y:9}] }
    };

    function createEntity(config) {
        const entity = { ...config };
        entity.x = config.start.x;
        entity.y = config.start.y;
        entity.px = entity.x * TILE_SIZE + TILE_SIZE / 2;
        entity.py = entity.y * TILE_SIZE + TILE_SIZE / 2;
        entity.isMoving = false;
        entity.targetX = entity.x;
        entity.targetY = entity.y;
        entity.speed = 4;
        entity.isAlive = true;
        return entity;
    }

    function createPlayer(config) {
        const player = createEntity(config);
        player.lives = 5; // Start with 5 lives
        player.bombsMax = 1;
        player.bombRange = 1;
        player.specialBombs = 0;
        player.canWalkThroughWalls = false;
        player.canWalkThroughBombs = false;
        player.canKickBomb = false;
        player.canDestroyWalls = false;
        player.isHit = false;
        player.hitTimer = 0;
        player.bombCooldown = 0;
        player.lastBombTime = 0;
        player.lastBombX = -1;
        player.lastBombY = -1;
        player.isInvincible = false;
        player.invincibilityTimer = 0;
        return player;
    }
    
    function resetTemporaryPowerups(player) {
        player.canWalkThroughWalls = false;
        player.canWalkThroughBombs = false;
        player.canKickBomb = false;
        player.canDestroyWalls = false;
        player.specialBombs = 0;
        player.speed = 4;
        player.isInvincible = false;
        player.invincibilityTimer = 0;
    }

    // --- Pomocn√© a UI funkce ---
    function getTile(x, y) {
        if (isNaN(x) || isNaN(y) || x < 0 || x >= COLS || y < 0 || y >= ROWS) {
            return TILES.INDESTRUCTIBLE;
        }
        return levelMap[y][x];
    }
    function isBombAt(x, y) { return bombs.some(bomb => bomb.x === x && bomb.y === y); }

    function showModal(title, text, buttonText, onButtonClick) {
        gameState.isPaused = true;
        const modal = document.getElementById('messageModal');
        document.getElementById('modalTitle').innerText = title;
        document.getElementById('modalText').innerText = text;
        const button = document.getElementById('modalButton');
        button.innerText = buttonText;
        button.onclick = () => {
            modal.style.display = 'none';
            if (onButtonClick) onButtonClick();
        };
        modal.style.display = 'flex';
    }
    
    function updateInfoPanel() {
        const infoPanel = document.getElementById('infoPanel');
        infoPanel.innerHTML = '';
        if (!gameState.gameActive) return;
        
        // Zobrazen√≠ stavu port√°lu a kl√≠ƒçe
        if (!levelDesigns[gameState.currentLevel].isFinalLevel) {
             const portalStatus = document.createElement('div');
             portalStatus.className = 'player-info';
             let statusText = "";
             if (gameState.keyFound) {
                 statusText += `<span>Kl√≠ƒç: ‚úÖ </span>`;
                 statusText += `<span>Port√°l: üåÄ OTEV≈òEN!</span>`;
                 portalStatus.style.color = '#48bb78';
                 portalStatus.style.fontWeight = 'bold';
             } else {
                 statusText += `<span>Kl√≠ƒç: ‚ùå</span>`;
                 statusText += `<span>Port√°l: üîí</span>`;
                 portalStatus.style.color = '#e53e3e';
             }
             portalStatus.innerHTML = statusText;
             infoPanel.appendChild(portalStatus);
        }

        players.forEach((p, i) => {
            const playerDiv = document.createElement('div');
            playerDiv.className = 'player-info';
            const livesHTML = p.symbol.repeat(p.lives);
            
            let powerUpsHTML = `<div class="flex items-center ml-2 border-l-2 border-gray-500 pl-2">`;
            powerUpsHTML += `<span>${powerUpTypes.range.symbol.repeat(p.bombRange)}</span>`;
            powerUpsHTML += `<span class="ml-2">${powerUpTypes.extra_bomb.symbol.repeat(p.bombsMax)}</span>`;
            if (p.canKickBomb) powerUpsHTML += `<span class="ml-2">${powerUpTypes.kick_bomb.symbol}</span>`;
            if (p.canWalkThroughWalls) powerUpsHTML += `<span class="ml-2">${powerUpTypes.walk_walls.symbol}</span>`;
            if (p.canWalkThroughBombs) powerUpsHTML += `<span class="ml-2">${powerUpTypes.walk_bombs.symbol}</span>`;
            if (p.speed > 4) powerUpsHTML += `<span class="ml-2">${powerUpTypes.speed.symbol}</span>`;
            if (p.canDestroyWalls) powerUpsHTML += `<span class="ml-2">${powerUpTypes.wall_destroyer.symbol}</span>`;
            if (p.specialBombs > 0) powerUpsHTML += `<span class="ml-2">${powerUpTypes.wall_destroyer.symbol.repeat(p.specialBombs)}</span>`;
            if (p.isInvincible) powerUpsHTML += `<span class="ml-2 animate-pulse text-yellow-300">${powerUpTypes.invincibility.symbol}</span>`;
            powerUpsHTML += `</div>`;

            playerDiv.innerHTML = `<span>Hr√°ƒç ${i+1}:</span> <span>${livesHTML}</span> ${powerUpsHTML}`;
            infoPanel.appendChild(playerDiv);
        });
        if (boss && boss.isAlive) {
            const bossDiv = document.createElement('div');
            bossDiv.className = 'player-info';
            bossDiv.innerHTML = `<span>BOSS:</span> <span class="text-red-500">${'‚ù§Ô∏è'.repeat(boss.hp)}</span>`;
            infoPanel.appendChild(bossDiv);
        }
    }

    // --- Generov√°n√≠ levelu ---
    function generateLevel() {
        levelMap = Array.from({ length: ROWS }, () => Array(COLS).fill(TILES.EMPTY));
        for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) {
            if (y === 0 || y === ROWS - 1 || x === 0 || x === COLS - 1 || (y % 2 === 0 && x % 2 === 0)) {
                levelMap[y][x] = TILES.INDESTRUCTIBLE;
            }
        }
        let destructibleWalls = [];
        const levelData = levelDesigns[gameState.currentLevel];
        if (!levelData.isBossLevel && !levelData.isFinalLevel) {
            for (let y = 1; y < ROWS - 1; y++) {
                for (let x = 1; x < COLS - 1; x++) {
                    const isStartArea = PLAYER_CONFIG.some(p => Math.abs(p.start.x - x) < 2 && Math.abs(p.start.y - y) < 2);
                    if (levelMap[y][x] === TILES.EMPTY && !isStartArea) {
                        if(Math.random() > 0.25) { // Sn√≠≈æen√° hustota zd√≠ (z 0.2 na 0.25 = 75% ≈°ance)
                            levelMap[y][x] = TILES.DESTRUCTIBLE;
                            destructibleWalls.push({x, y});
                        }
                    }
                }
            }
            
            // Um√≠stƒõn√≠ port√°lu a kl√≠ƒçe
            gameState.portal = { x: -1, y: -1 };
            if (destructibleWalls.length >= 2) {
                 // Port√°l
                 let idx = Math.floor(Math.random() * destructibleWalls.length);
                 gameState.portal = destructibleWalls[idx];
                 destructibleWalls.splice(idx, 1);
                 
                 // Kl√≠ƒç
                 idx = Math.floor(Math.random() * destructibleWalls.length);
                 const keyPos = destructibleWalls[idx];
                 powerUps.push({x: keyPos.x, y: keyPos.y, type: 'key', symbol: powerUpTypes['key'].symbol});
                 destructibleWalls.splice(idx, 1);
            }

            // V√≠ce bonus≈Ø: 6 a≈æ 10 bonus≈Ø na level
            const numPowerUps = Math.min(Math.floor(Math.random() * 5) + 6, destructibleWalls.length);
            for(let i = 0; i < numPowerUps; i++) {
                const powerUpKey = weightedPowerUps[Math.floor(Math.random() * weightedPowerUps.length)];
                const wallIndex = Math.floor(Math.random() * destructibleWalls.length);
                const wall = destructibleWalls.splice(wallIndex, 1)[0];
                powerUps.push({x: wall.x, y: wall.y, type: powerUpKey, symbol: powerUpTypes[powerUpKey].symbol});
            }
        } else if (levelData.isBossLevel) {
             // Pro boss level port√°l uprost≈ôed
             gameState.portal = { x: Math.floor(COLS/2), y: Math.floor(ROWS/2) };
             // Kl√≠ƒç se objev√≠ po smrti bosse
        }
    }

    function spawnEntities() {
        const levelData = levelDesigns[gameState.currentLevel];
        gameState.enemiesRemaining = levelData.enemyCount;
        enemies = [];
        boss = null;
        fighterJet = null;
        projectiles = [];
        bossProjectiles = [];

        if (levelData.isBossLevel) {
            boss = createEntity({start: {x: Math.floor(COLS / 2), y: 2}});
            boss.symbol = 'ü¶ç';
            boss.hp = 10;
            boss.isHit = false;
            boss.hitTimer = 0;
            boss.moveCounter = 120;

            fighterJet = createEntity({start: {x: 1, y: Math.floor(ROWS/2)}});
            fighterJet.symbol = '‚úàÔ∏è';
            fighterJet.attackTimer = 120;
            fighterJet.speed = 4; // Zpomalen√≠ st√≠haƒçky
            
            gameState.enemiesRemaining = 2; // Boss + Jet
        } else if (levelData.enemyCount > 0) {
            let placedCount = 0;
            let safetyBreak = 0;
            while (placedCount < levelData.enemyCount && safetyBreak < 100) {
                let placed = false;
                let attempts = 0;
                
                // Zkus√≠me naj√≠t m√≠sto. Pokud to trv√° moc dlouho, sn√≠≈æ√≠me n√°roky na vzd√°lenost.
                while (!placed && attempts < 50) {
                    attempts++;
                    const x = Math.floor(Math.random() * (COLS - 2)) + 1;
                    const y = Math.floor(Math.random() * (ROWS - 2)) + 1;
                    
                    // Bezpeƒçn√° vzd√°lenost (zmen≈°uje se s poƒçtem pokus≈Ø)
                    let safeDistance = 9;
                    if (safetyBreak > 20) safeDistance = 6;
                    if (safetyBreak > 50) safeDistance = 3;

                    const isTooClose = PLAYER_CONFIG.some(p => (Math.abs(p.start.x - x) + Math.abs(p.start.y - y)) < safeDistance);
                    
                    if (getTile(x, y) === TILES.EMPTY && !isTooClose) {
                        const enemy = createEntity({start: {x, y}});
                        enemy.type = levelData.enemyType;
                        enemy.moveCounter = 0;
                        enemies.push(enemy);
                        placed = true;
                        placedCount++;
                    }
                }
                safetyBreak++;
            }
            // Update skuteƒçn√©ho poƒçtu, kdyby se nepoda≈ôilo um√≠stit v≈°echny
            gameState.enemiesRemaining = enemies.length;
        }
    }

    function initializeLevel(level) {
        gameState.isPaused = false;
        gameState.currentLevel = level;
        gameState.kingArrived = false;
        gameState.keyFound = false; // Reset kl√≠ƒçe
        
        // V boss levelu a posledn√≠m levelu je kl√≠ƒç automaticky "nalezen" (nebo se to ≈ôe≈°√≠ jinak)
        if (levelDesigns[level].isBossLevel || levelDesigns[level].isFinalLevel) {
             gameState.keyFound = true; 
        }

        players.forEach(p => {
            p.x = p.start.x; p.y = p.start.y;
            // Pozice v pixelech se nyn√≠ nastavuje dynamicky v draw/update podle TILE_SIZE,
            // ale pro jistotu zde nastav√≠me z√°kladn√≠ hodnoty, kter√© se hned p≈ôepoƒç√≠taj√≠.
            p.px = p.x * TILE_SIZE + TILE_SIZE / 2;
            p.py = p.y * TILE_SIZE + TILE_SIZE / 2;
            p.isMoving = false;
            resetTemporaryPowerups(p);
        });
        bombs = []; explosions = []; powerUps = [];
        generateLevel();
        spawnEntities();
        if (levelDesigns[level].isFinalLevel) {
            initializePuzzle();
        }
        
        // Zavolat resize pro p≈ôepoƒç√≠t√°n√≠ pozic
        resizeGame();
        
        updateInfoPanel();
    }
    
    function resetAndStartLobby() {
        gameState.gameActive = false;
        gameState.isPaused = false;
        gameState.killCount = 0;
        players = [];
        initializeLevel(1);
        gameLoop();
    }

    // --- Hern√≠ smyƒçka ---
    function gameLoop() {
        if (gameState.inputCooldown > 0) gameState.inputCooldown--;
        handleInputs();
        if (gameState.gameActive && !gameState.isPaused) {
            update();
        }
        draw();
        requestAnimationFrame(gameLoop);
    }

    // --- Update logika ---
    function update() {
        updatePositions();
        players.forEach(p => {
            if (p.bombCooldown > 0) p.bombCooldown--;
            if (p.isHit) {
                p.hitTimer--;
                if (p.hitTimer <= 0) p.isHit = false;
            }
            if (p.isInvincible) {
                p.invincibilityTimer--;
                if (p.invincibilityTimer <= 0) {
                    p.isInvincible = false;
                    updateInfoPanel();
                }
            }
        });
        moveEnemies();
        updateBombs();
        if (boss && boss.isAlive) updateBoss();
        if (fighterJet && fighterJet.isAlive) updateFighterJet();
        updateProjectiles();
        updateBossProjectiles();
        checkCollisions();
    }
    
    function updatePositions() {
        const allEntities = [...players, ...enemies, boss, fighterJet].filter(e => e);
        allEntities.forEach(entity => {
            // Zajistit, ≈æe pixelov√© sou≈ôadnice odpov√≠daj√≠ aktu√°ln√≠mu TILE_SIZE, pokud se neh√Ωbe
            if (!entity.isMoving) {
                 entity.px = entity.x * TILE_SIZE + TILE_SIZE / 2;
                 entity.py = entity.y * TILE_SIZE + TILE_SIZE / 2;
                 return;
            }

            const targetPX = entity.targetX * TILE_SIZE + TILE_SIZE / 2;
            const targetPY = entity.targetY * TILE_SIZE + TILE_SIZE / 2;
            const dx = targetPX - entity.px;
            const dy = targetPY - entity.py;
            
            // Rychlost pohybu mus√≠ b√Ωt tak√© z√°visl√° na TILE_SIZE, aby to na velk√Ωch displej√≠ch nebylo pomal√©
            // Z√°kladn√≠ rychlost 4 p≈ôi TILE_SIZE 40 => pomƒõr 0.1
            const currentSpeed = entity.speed * (TILE_SIZE / 40); 

            if (Math.abs(dx) < currentSpeed && Math.abs(dy) < currentSpeed) {
                entity.px = targetPX;
                entity.py = targetPY;
                entity.x = entity.targetX;
                entity.y = entity.targetY;
                entity.isMoving = false;
            } else {
                entity.px += Math.sign(dx) * currentSpeed;
                entity.py += Math.sign(dy) * currentSpeed;
            }
        });
    }

    function moveEnemies() {
        enemies.forEach(enemy => {
            if (enemy.isMoving) return;
            enemy.moveCounter--;
            if (enemy.moveCounter <= 0) {
                const directions = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];
                const dir = directions[Math.floor(Math.random() * directions.length)];
                moveEntity(enemy, dir.x, dir.y);
                enemy.moveCounter = Math.floor(Math.random() * 30) + 15; // Faster movement
            }
        });
    }

    function updateBoss() {
        if (boss.isHit) {
            boss.hitTimer--;
            if (boss.hitTimer <= 0) boss.isHit = false;
        }
        
        if (!boss.isMoving) {
            boss.moveCounter--;
            if (boss.moveCounter <= 0) {
                const directions = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];
                const dir = directions[Math.floor(Math.random() * directions.length)];
                moveEntity(boss, dir.x, dir.y);
                boss.moveCounter = 90 + Math.random() * 60;
            }
        }

        boss.attackTimer--;
        if (boss.attackTimer <= 0) {
            const activePlayers = players.filter(p => p.isAlive);
            if (activePlayers.length > 0) {
                const targetPlayer = activePlayers[Math.floor(Math.random() * activePlayers.length)];
                if (Math.random() > 0.5) { // Laser
                    const isHorizontal = Math.random() > 0.5;
                    const line = isHorizontal ? targetPlayer.y : targetPlayer.x;
                    lasers.push({ isHorizontal, line, timer: 120, state: 'warning' });
                } else { // Kokosov√° bomba
                    bossProjectiles.push({ x: targetPlayer.x, y: targetPlayer.y, timer: 90, state: 'warning' });
                }
            }
            boss.attackTimer = 120 + Math.random() * 60;
        }
        lasers.forEach(l => { if (l.state === 'warning' && l.timer < 60) l.state = 'firing'; });
    }

    function updateFighterJet() {
        if (!fighterJet.isMoving) {
            fighterJet.moveCounter = (fighterJet.moveCounter || 0) - 1;
            if (fighterJet.moveCounter <= 0) {
                const directions = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];
                const dir = directions[Math.floor(Math.random() * directions.length)];
                moveEntity(fighterJet, dir.x, dir.y);
                fighterJet.moveCounter = Math.floor(Math.random() * 20) + 10;
            }
        }
        fighterJet.attackTimer--;
        if (fighterJet.attackTimer <= 0) {
            const activePlayers = players.filter(p => p.isAlive);
            let fired = false;

            for (const player of activePlayers) {
                let pathIsClear = true;
                // Vertical check
                if (player.x === fighterJet.x) {
                    for (let y = Math.min(player.y, fighterJet.y) + 1; y < Math.max(player.y, fighterJet.y); y++) {
                        if (getTile(fighterJet.x, y) !== TILES.EMPTY) {
                            pathIsClear = false;
                            break;
                        }
                    }
                    if (pathIsClear) {
                        const vy = Math.sign(player.py - fighterJet.py) * 8 * (TILE_SIZE/40);
                        projectiles.push({px: fighterJet.px, py: fighterJet.py, vx: 0, vy: vy, symbol: '‚ö°', timer: 180});
                        fired = true;
                        break;
                    }
                }
                // Horizontal check
                if (player.y === fighterJet.y) {
                    for (let x = Math.min(player.x, fighterJet.x) + 1; x < Math.max(player.x, fighterJet.x); x++) {
                        if (getTile(x, fighterJet.y) !== TILES.EMPTY) {
                            pathIsClear = false;
                            break;
                        }
                    }
                    if (pathIsClear) {
                        const vx = Math.sign(player.px - fighterJet.px) * 8 * (TILE_SIZE/40);
                        projectiles.push({px: fighterJet.px, py: fighterJet.py, vx: vx, vy: 0, symbol: '‚ö°', timer: 180});
                        fired = true;
                        break;
                    }
                }
            }
            fighterJet.attackTimer = 90 + Math.random() * 30;
        }
    }

    function updateProjectiles() {
        projectiles.forEach((p, index) => {
            p.px += p.vx;
            p.py += p.vy;
            p.timer--;
            const gridX = Math.round((p.px - TILE_SIZE / 2) / TILE_SIZE);
            const gridY = Math.round((p.py - TILE_SIZE / 2) / TILE_SIZE);

            if (p.timer <= 0 || getTile(gridX, gridY) !== TILES.EMPTY) {
                projectiles.splice(index, 1);
            }
        });
    }

    function updateBossProjectiles() {
        bossProjectiles.forEach(proj => {
            proj.timer--;
            if (proj.state === 'warning' && proj.timer <= 0) {
                proj.state = 'exploding';
                proj.timer = 20;
                createExplosion(proj.x, proj.y, 1);
            }
        });
        bossProjectiles = bossProjectiles.filter(p => p.timer > 0);
    }

    function updateBombs() {
        explosions = explosions.filter(e => --e.timer > 0);
        bombs.forEach(bomb => {
            if (bomb.isKicked) {
                bomb.kickTimer--;
                if (bomb.kickTimer <= 0) {
                    bomb.kickTimer = 8;
                    const nextX = bomb.x + bomb.vx;
                    const nextY = bomb.y + bomb.vy;
                    if (getTile(nextX, nextY) === TILES.EMPTY && !isBombAt(nextX, nextY)) {
                        bomb.x = nextX;
                        bomb.y = nextY;
                    } else {
                        bomb.isKicked = false;
                    }
                }
            }
            bomb.timer--;
            if (bomb.timer <= 0 && !bomb.exploded) {
                triggerExplosion(bomb);
            }
        });
        bombs = bombs.filter(bomb => !bomb.exploded);
    }

    function triggerExplosion(bomb) {
        if (bomb.exploded) return;
        bomb.exploded = true;
        const owner = players.find(p => p.id === bomb.ownerId);
        createExplosion(bomb.x, bomb.y, owner ? owner.bombRange : 1, bomb.isSpecial);
    }

    function createExplosion(x, y, range, isSpecial = false) {
        const explosionTiles = [{ x, y, timer: 20 }];
        const directions = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];
        directions.forEach(dir => {
            for (let i = 1; i <= range; i++) {
                const ex = x + dir.x * i;
                const ey = y + dir.y * i;
                const tile = getTile(ex, ey);

                if (tile === TILES.EMPTY) {
                    explosionTiles.push({ x: ex, y: ey, timer: 20 });
                    bombs.forEach(b => { if(b.x === ex && b.y === ey) triggerExplosion(b); });
                    continue;
                }
                
                explosionTiles.push({ x: ex, y: ey, timer: 20 });

                if (tile === TILES.DESTRUCTIBLE) {
                    levelMap[ey][ex] = TILES.EMPTY;
                    // Spawn bonus po zniƒçen√≠ zdi s malou ≈°anc√≠ nebo speci√°ln√≠ pravidlo
                    if (gameState.portal.x === ex && gameState.portal.y === ey) {
                        // Portal revealed (visual only here, handled in draw)
                    } else {
                         // Pokud je na tomto m√≠stƒõ kl√≠ƒç, tak se objev√≠. Pokud ne, tak mo≈æn√° bonus
                         // (bonusy se generuj√≠ v generateLevel a jsou u≈æ v poli powerUps na sou≈ôadnic√≠ch)
                    }
                } else if (tile === TILES.INDESTRUCTIBLE && isSpecial) {
                    if (ex > 0 && ex < COLS - 1 && ey > 0 && ey < ROWS - 1) {
                        levelMap[ey][ex] = TILES.EMPTY;
                        const powerUpKey = weightedPowerUps[Math.floor(Math.random() * weightedPowerUps.length)];
                        powerUps.push({x: ex, y: ey, type: powerUpKey, symbol: powerUpTypes[powerUpKey].symbol});
                    }
                }
                
                if (isSpecial) {
                    const perpendicularDirs = (dir.x === 0)
                        ? [{x: 1, y: 0}, {x: -1, y: 0}]
                        : [{x: 0, y: 1}, {x: 0, y: -1}];
                    
                    perpendicularDirs.forEach(pDir => {
                        const splashX = ex + pDir.x;
                        const splashY = ey + pDir.y;
                        if (getTile(splashX, splashY) === TILES.EMPTY) {
                            explosionTiles.push({ x: splashX, y: splashY, timer: 20 });
                        }
                    });
                }

                break; 
            }
        });
        explosions.push(...explosionTiles);
    }

    function checkCollisions() {
        const levelData = levelDesigns[gameState.currentLevel];
        const currentEnemyName = (levelData && levelData.enemyName) ? levelData.enemyName.slice(0, -1).toLowerCase() : "";

        players.forEach((p) => {
            if (!p.isAlive || p.isHit) return;
            let hit = false;
            if (!p.isInvincible) {
                if (currentEnemyName) {
                    enemies.forEach(enemy => { if (enemy.x === p.x && enemy.y === p.y) hit = `Chytil tƒõ ${currentEnemyName}!`; });
                }
                if (boss && boss.isAlive && p.x === boss.x && p.y === boss.y) hit = "Rozmaƒçkal tƒõ Kr√°l Opic!";
                
                explosions.forEach(exp => { if (exp.x === p.x && exp.y === p.y) hit = "Zas√°hla tƒõ exploze!"; });
                
                projectiles.forEach((proj, index) => {
                    const dist = Math.sqrt(Math.pow(p.px - proj.px, 2) + Math.pow(p.py - proj.py, 2));
                    if (dist < TILE_SIZE / 2) {
                        hit = "Zas√°hl tƒõ laser!";
                        projectiles.splice(index, 1);
                    }
                });

                if (hit) handlePlayerHit(p, hit);
            }
        });

        explosions.forEach(exp => {
            enemies = enemies.filter(enemy => {
                if (enemy.x === exp.x && enemy.y === exp.y) {
                    gameState.enemiesRemaining--;
                    gameState.killCount++;
                    if (gameState.killCount > 0 && gameState.killCount % 18 === 0) {
                        players.forEach(p => { if(p.isAlive) p.lives++; });
                    }
                    updateInfoPanel();
                    return false;
                }
                return true;
            });
            if (boss && boss.isAlive && !boss.isHit && exp.x === boss.x && exp.y === boss.y) {
                boss.hp--;
                boss.isHit = true;
                boss.hitTimer = 30;
                if (boss.hp <= 0) {
                    boss.isAlive = false;
                    gameState.enemiesRemaining--;
                }
                updateInfoPanel();
            }
            if (fighterJet && fighterJet.isAlive && exp.x === fighterJet.x && exp.y === fighterJet.y) {
                fighterJet.isAlive = false;
                gameState.enemiesRemaining--;
                updateInfoPanel();
            }
        });
        
        players.forEach(p => {
             powerUps.forEach((powerUp, index) => {
                if(getTile(powerUp.x, powerUp.y) === TILES.EMPTY && p.x === powerUp.x && p.y === powerUp.y) {
                    switch(powerUp.type) {
                        case 'range': p.bombRange++; break;
                        case 'extra_bomb': p.bombsMax++; break;
                        case 'walk_walls': p.canWalkThroughWalls = true; break;
                        case 'walk_bombs': p.canWalkThroughBombs = true; break;
                        case 'kick_bomb': p.canKickBomb = true; break;
                        case 'speed': p.speed += 2; break;
                        case 'extra_life': p.lives++; break;
                        case 'wall_destroyer': p.specialBombs++; break;
                    }
                    powerUps.splice(index, 1);
                    updateInfoPanel();
                }
            });
            
            // Check for Portal Entry
            if (!levelData.isFinalLevel && !levelData.isBossLevel) {
                 if (gameState.portal && p.x === gameState.portal.x && p.y === gameState.portal.y) {
                     if (gameState.keyFound) {
                        levelComplete();
                     }
                 }
            } else if (levelData.isBossLevel && gameState.enemiesRemaining <= 0) {
                 // V boss levelu staƒç√≠ porazit bosse (kl√≠ƒç je automaticky)
                 levelComplete();
            }
        });

        // Automatick√© dokonƒçen√≠ bylo odstranƒõno dle po≈æadavku.

        if (levelData.isFinalLevel && !gameState.isPaused) {
            const kingX = Math.floor(COLS / 2);
            const kingY = 2;
            if (!gameState.kingArrived) {
                if (checkPuzzleSolved()) {
                    gameState.kingArrived = true;
                }
            } else {
                if (players.some(p => p.isAlive && p.x === kingX && p.y === kingY)) {
                    showFinalScene();
                }
            }
        }
    }
    
    // --- Stavy hr√°ƒçe a postup ---
    function handlePlayerHit(player, reason) {
        if (!player.isAlive) return;
        player.lives--;
        resetTemporaryPowerups(player);
        if (player.lives <= 0) {
            player.isAlive = false;
        } else {
            player.isHit = true;
            player.hitTimer = 120;
            player.x = player.start.x; player.y = player.start.y;
            player.px = player.x * TILE_SIZE + TILE_SIZE / 2;
            player.py = player.y * TILE_SIZE + TILE_SIZE / 2;
            player.isMoving = false;
        }
        updateInfoPanel();
        
        if (players.every(pl => !pl.isAlive)) {
            gameOver(reason);
        }
    }

    function gameOver(reason) {
        gameState.gameActive = false;
        showModal("Konec hry!", reason, "Hr√°t znovu?", resetAndStartLobby);
    }

    function levelComplete() {
        gameState.isPaused = true;
        const nextLevel = gameState.currentLevel + 1;
        if (levelDesigns[nextLevel]) {
             showModal("Level dokonƒçen!", "Poraƒè si s dal≈°√≠ v√Ωzvou.", "Dal≈°√≠ level", () => initializeLevel(nextLevel));
        }
    }

    function showFinalScene() {
        gameState.isPaused = true;
        const dialogue = "Kr√°l ban√°n≈Ø üëë: 'Skvƒõl√° pr√°ce, ovocn√≠ hrdinov√©! Jste hodni svobody!'";
        showModal("Setk√°n√≠ s kr√°lem", dialogue, "Hr√°t znovu?", resetAndStartLobby);
    }

    // --- Kreslen√≠ ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const levelData = levelDesigns[gameState.currentLevel];
        canvas.style.backgroundColor = levelData.bgColor;

        ctx.font = `${TILE_SIZE * 0.8}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        ctx.fillStyle = 'black';
        for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) {
            const tile = getTile(x, y);
            let symbol = '';
            if (tile === TILES.INDESTRUCTIBLE) symbol = levelData.wallType;
            if (tile === TILES.DESTRUCTIBLE) symbol = levelData.destructibleWallType;
            if (symbol) ctx.fillText(symbol, x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
        }
        
        if (!gameState.gameActive) {
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(0, canvas.height / 2 - 30, canvas.width, 60);
            ctx.fillStyle = "white";
            ctx.font = "20px 'Press Start 2P'";
            ctx.fillText("Stisknƒõte kl√°vesu nebo tlaƒç√≠tko", canvas.width / 2, canvas.height / 2 - 10);
            ctx.fillText("pro p≈ôipojen√≠ do hry!", canvas.width / 2, canvas.height / 2 + 20);
            return;
        }
        
        // Draw Portal
        if (!levelData.isFinalLevel && !levelData.isBossLevel && gameState.portal.x !== -1 && levelMap[gameState.portal.y][gameState.portal.x] === TILES.EMPTY) {
            if (gameState.keyFound) {
                 // Active
                 ctx.save();
                 const angle = Date.now() / 200;
                 ctx.translate(gameState.portal.x * TILE_SIZE + TILE_SIZE / 2, gameState.portal.y * TILE_SIZE + TILE_SIZE / 2);
                 ctx.rotate(angle);
                 ctx.font = `${TILE_SIZE}px sans-serif`;
                 ctx.fillText('üåÄ', 0, 0);
                 ctx.restore();
            } else {
                 // Inactive
                 ctx.font = `${TILE_SIZE * 0.8}px sans-serif`;
                 ctx.filter = 'grayscale(100%)';
                 ctx.fillText('üîí', gameState.portal.x * TILE_SIZE + TILE_SIZE / 2, gameState.portal.y * TILE_SIZE + TILE_SIZE / 2);
                 ctx.filter = 'none';
            }
        }
        
        if (levelData.isFinalLevel && !gameState.kingArrived) {
            drawPuzzle();
        }

        powerUps.forEach(p => { if(getTile(p.x, p.y) === TILES.EMPTY) ctx.fillText(p.symbol, p.x * TILE_SIZE + TILE_SIZE / 2, p.y * TILE_SIZE + TILE_SIZE / 2); });
        
        bombs.forEach(bomb => {
            ctx.save();
            if (bomb.isSpecial) {
                const scale = 1 + Math.sin(Date.now() / 100) * 0.1;
                ctx.translate(bomb.x * TILE_SIZE + TILE_SIZE / 2, bomb.y * TILE_SIZE + TILE_SIZE / 2);
                ctx.scale(scale, scale);
                ctx.fillText('üí£', 0, 0);
            } else {
                ctx.fillText('üí£', bomb.x * TILE_SIZE + TILE_SIZE / 2, bomb.y * TILE_SIZE + TILE_SIZE / 2);
            }
            ctx.restore();
        });
        
        explosions.forEach(exp => {
            const centerX = exp.x * TILE_SIZE + TILE_SIZE / 2;
            const centerY = exp.y * TILE_SIZE + TILE_SIZE / 2;
            const progress = exp.timer / 20;
            const grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, TILE_SIZE / 2 * progress);
            grad.addColorStop(0, 'white'); grad.addColorStop(0.5, 'yellow'); grad.addColorStop(1, 'rgba(255, 165, 0, 0.7)');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(centerX, centerY, TILE_SIZE / 2 * progress, 0, 2 * Math.PI); ctx.fill();
        });

        projectiles.forEach(p => { ctx.fillStyle = 'red'; ctx.fillText(p.symbol, p.px, p.py); });

        drawBossProjectiles();

        players.forEach(p => {
            if (p.isAlive) {
                ctx.save();
                // Blinking if recently hit or invincibility effect
                if (p.isHit && Math.floor(p.hitTimer / 10) % 2 === 0) {
                     ctx.globalAlpha = 0.5;
                } else if (p.isInvincible) {
                     // Gold glow effect
                     ctx.shadowColor = 'gold';
                     ctx.shadowBlur = 10 + Math.sin(Date.now() / 100) * 5;
                } else {
                     ctx.globalAlpha = 1.0;
                     ctx.shadowBlur = 0;
                }
                
                ctx.fillStyle = 'black';
                ctx.fillText(p.symbol, p.px, p.py);
                ctx.restore();
            }
        });
        
        ctx.fillStyle = 'black';
        enemies.forEach(enemy => ctx.fillText(enemy.type, enemy.px, enemy.py));
        if (boss && boss.isAlive) {
            ctx.save();
            ctx.globalAlpha = (boss.isHit && Math.floor(boss.hitTimer / 10) % 2 === 0) ? 0.5 : 1.0;
            ctx.font = `${TILE_SIZE * 1.5}px sans-serif`;
            ctx.fillText(boss.symbol, boss.px, boss.py);
            ctx.restore();
        }
        if (fighterJet && fighterJet.isAlive) {
             ctx.fillText(fighterJet.symbol, fighterJet.px, fighterJet.py);
        }

        if (levelData.isFinalLevel && gameState.kingArrived) {
            ctx.font = `${TILE_SIZE * 2}px sans-serif`;
            ctx.fillText('üëë', canvas.width / 2, TILE_SIZE * 2);
        }
    }

    function drawLasers() {
        lasers.forEach(l => {
            if (l.state === 'warning') {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                if (l.isHorizontal) ctx.fillRect(0, l.line * TILE_SIZE, canvas.width, TILE_SIZE);
                else ctx.fillRect(l.line * TILE_SIZE, 0, TILE_SIZE, canvas.height);
            } else if (l.state === 'firing') {
                ctx.fillStyle = 'red';
                if (l.isHorizontal) ctx.fillRect(0, l.line * TILE_SIZE, canvas.width, TILE_SIZE);
                else ctx.fillRect(l.line * TILE_SIZE, 0, TILE_SIZE, canvas.height);
            }
        });
    }

    function drawBossProjectiles() {
        bossProjectiles.forEach(p => {
            if (p.state === 'warning') {
                ctx.fillStyle = 'rgba(255, 165, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(p.x * TILE_SIZE + TILE_SIZE / 2, p.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.fillText('ü••', p.x * TILE_SIZE + TILE_SIZE / 2, p.y * TILE_SIZE + TILE_SIZE / 2);
            }
        });
    }

    // --- Ovl√°d√°n√≠ ---
    let touchPlayer = null;
    let touchIdentifier = null;
    let touchStartX = 0, touchStartY = 0;
    let joystickActive = false;
    let touchDirection = { x: 0, y: 0 };
    let touchInputDetected = false;

    function placeBomb(player) {
        if (!player || !player.isAlive || player.bombCooldown > 0 || gameState.inputCooldown > 0) return;
        
        const now = Date.now();
        const doubleTap = now - player.lastBombTime < 300 && player.lastBombX === player.x && player.lastBombY === player.y;

        if (doubleTap && player.specialBombs > 0) {
            const lastBombIndex = bombs.findIndex(b => b.x === player.x && b.y === player.y && !b.isSpecial);
            if (lastBombIndex > -1) bombs.splice(lastBombIndex, 1);
            
            bombs.push({ x: player.x, y: player.y, timer: 120, exploded: false, ownerId: player.id, isKicked: false, vx: 0, vy: 0, kickTimer: 0, isSpecial: true });
            player.specialBombs--;
            player.lastBombTime = 0;
            updateInfoPanel();
        } else if (bombs.filter(b => b.ownerId === player.id).length < player.bombsMax && !isBombAt(player.x, player.y)) {
            bombs.push({ x: player.x, y: player.y, timer: 120, exploded: false, ownerId: player.id, isKicked: false, vx: 0, vy: 0, kickTimer: 0, isSpecial: false });
            player.bombCooldown = 15;
            player.lastBombTime = now;
            player.lastBombX = player.x;
            player.lastBombY = player.y;
        }
    }

    function moveEntity(entity, dx, dy) {
        if (!entity || !entity.isAlive || entity.isMoving) return;
        const newX = entity.x + dx;
        const newY = entity.y + dy;
        
        if (levelDesigns[gameState.currentLevel].isFinalLevel && !gameState.kingArrived) {
            if (tryMovePuzzlePiece(entity, dx, dy)) return;
        }

        const targetTile = getTile(newX, newY);
        const bombAtTarget = bombs.find(b => b.x === newX && b.y === newY);

        if (entity.canKickBomb && bombAtTarget && !bombAtTarget.isKicked) {
            bombAtTarget.isKicked = true;
            bombAtTarget.vx = dx;
            bombAtTarget.vy = dy;
            bombAtTarget.kickTimer = 8;
            return;
        }

        let canMove = false;
        if (targetTile === TILES.EMPTY || (targetTile === TILES.DESTRUCTIBLE && entity.canWalkThroughWalls)) canMove = true;
        if (bombAtTarget && !entity.canWalkThroughBombs) canMove = false;
        if (canMove) {
            entity.targetX = newX;
            entity.targetY = newY;
            entity.isMoving = true;
        }
    }

    function handleInputs() {
        // Cheaty
        const lastKey = keysPressed.lastKey;
        if (lastKey) {
            cheatBuffer += lastKey;
            keysPressed.lastKey = null;
            if (cheatBuffer.length > 10) cheatBuffer = cheatBuffer.slice(-10);
            const match = cheatBuffer.match(/LEVEL(\d+)/);
            if (match) {
                const levelNum = parseInt(match[1]);
                if (levelDesigns[levelNum]) {
                    if (!gameState.gameActive) {
                        players.push(createPlayer(PLAYER_CONFIG[2]));
                        gameState.gameActive = true;
                    }
                    initializeLevel(levelNum);
                    cheatBuffer = "";
                }
            }
        }

        // Potvrzen√≠ modalu
        if (gameState.isPaused) {
            const confirmKeyPressed = keysPressed['enter'];
            let bombButtonPressed = false;
            if (keysPressed[' '] || keysPressed['q']) bombButtonPressed = true;
            
            const gamepads = navigator.getGamepads();
            for (const gp of gamepads) {
                if (gp && gp.buttons[0].pressed) {
                    bombButtonPressed = true;
                    break;
                }
            }

            if (confirmKeyPressed || bombButtonPressed) {
                const modalButton = document.getElementById('modalButton');
                if (modalButton && modalButton.offsetParent !== null) {
                    if (!modalButton.disabled) {
                         modalButton.click();
                         modalButton.disabled = true;
                         gameState.inputCooldown = 15;
                         setTimeout(() => { modalButton.disabled = false; }, 500);
                    }
                }
            }
            return;
        }

        // P≈ôid√°n√≠ nov√Ωch hr√°ƒç≈Ø
        if (players.length < 4) {
            const assignedKeyboardIds = players.filter(p => p.controls.type === 'keyboard').map(p => p.id);
            const assignedGamepadIndices = players.filter(p => p.controls.type === 'gamepad' && typeof p.controls.index !== 'undefined').map(p => p.controls.index);
            const assignedTouch = players.some(p => p.controls.type === 'touch');

            if (touchInputDetected && !assignedTouch) {
                const availableConfig = PLAYER_CONFIG.find(c => !players.some(p => p.id === c.id));
                if (availableConfig) {
                    const newPlayer = createPlayer(availableConfig);
                    newPlayer.controls.type = 'touch';
                    touchPlayer = newPlayer;
                    players.push(newPlayer);
                    if (!gameState.gameActive) gameState.gameActive = true;
                    updateInfoPanel();
                }
            }
            for (const key in keysPressed) {
                if (keysPressed[key]) {
                    const config = PLAYER_CONFIG.find(c => c.controls.type === 'keyboard' && Object.values(c.controls).includes(key));
                    if (config && !assignedKeyboardIds.includes(config.id)) {
                        players.push(createPlayer(config));
                        if (!gameState.gameActive) gameState.gameActive = true;
                        updateInfoPanel();
                    }
                }
            }
            const gamepads = navigator.getGamepads();
            for (const gp of gamepads) {
                if (!gp || assignedGamepadIndices.includes(gp.index)) continue;
                const isActive = gp.buttons.some(b => b.pressed) || gp.axes.some(a => Math.abs(a) > 0.5);
                if (isActive) {
                     const assignedGamepadConfigIds = players.filter(p => p.controls.type === 'gamepad').map(p => p.id);
                     const availableConfig = PLAYER_CONFIG.find(c => c.controls.type === 'gamepad' && !assignedGamepadConfigIds.includes(c.id));
                     if (availableConfig) {
                         const newPlayer = createPlayer(availableConfig);
                         newPlayer.controls.index = gp.index;
                         players.push(newPlayer);
                         if (!gameState.gameActive) gameState.gameActive = true;
                         updateInfoPanel();
                     }
                }
            }
        }

        // Ovl√°d√°n√≠ aktivn√≠ch hr√°ƒç≈Ø
        players.forEach(p => {
            if (!p.isAlive) return;
            if (p.controls.type === 'keyboard') {
                if (keysPressed[p.controls.up]) moveEntity(p, 0, -1);
                else if (keysPressed[p.controls.down]) moveEntity(p, 0, 1);
                else if (keysPressed[p.controls.left]) moveEntity(p, -1, 0);
                else if (keysPressed[p.controls.right]) moveEntity(p, 1, 0);
                if (keysPressed[p.controls.bomb]) placeBomb(p);
            } else if (p.controls.type === 'gamepad') {
                if (typeof p.controls.index === 'undefined') return;
                const gp = navigator.getGamepads()[p.controls.index];
                if (!gp) return;
                if (gp.buttons[0].pressed) placeBomb(p);
                const deadzone = 0.5;
                const dx = gp.axes[0];
                const dy = gp.axes[1];
                if (Math.abs(dx) > deadzone) moveEntity(p, Math.sign(dx), 0);
                else if (Math.abs(dy) > deadzone) moveEntity(p, 0, Math.sign(dy));
            } else if (p.controls.type === 'touch') {
                if (touchDirection.x !== 0 || touchDirection.y !== 0) {
                    moveEntity(p, touchDirection.x, touchDirection.y);
                }
            }
        });
    }

    window.addEventListener('keydown', (e) => { 
        const key = e.key.toLowerCase();
        keysPressed[key] = true; 
        keysPressed.lastKey = e.key.toUpperCase();
    });
    window.addEventListener('keyup', (e) => { keysPressed[e.key.toLowerCase()] = false; });

    // --- Dotykov√© ovl√°d√°n√≠ ---
    window.addEventListener('touchstart', (e) => {
        e.preventDefault();
        touchInputDetected = true;

        if (e.touches.length >= 2) {
            if (touchPlayer) placeBomb(touchPlayer);
            return;
        }
        
        const touch = e.changedTouches[0];
        if (!joystickActive) {
            joystickActive = true;
            touchIdentifier = touch.identifier;
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        }
    }, { passive: false });

    window.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!joystickActive) return;
        let touch = null;
        for (let t of e.changedTouches) {
            if (t.identifier === touchIdentifier) {
                touch = t;
                break;
            }
        }
        if (!touch) return;

        const deltaX = touch.clientX - touchStartX;
        const deltaY = touch.clientY - touchStartY;
        
        const threshold = 20;
        touchDirection = { x: 0, y: 0 };
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
            if (deltaX > threshold) touchDirection.x = 1;
            else if (deltaX < -threshold) touchDirection.x = -1;
        } else {
            if (deltaY > threshold) touchDirection.y = 1;
            else if (deltaY < -threshold) touchDirection.y = -1;
        }
    }, { passive: false });

    window.addEventListener('touchend', (e) => {
        e.preventDefault();
        for (let t of e.changedTouches) {
            if (t.identifier === touchIdentifier) {
                joystickActive = false;
                touchIdentifier = null;
                touchDirection = { x: 0, y: 0 };
                break;
            }
        }
    });

    // --- Puzzle logika ---
    function initializePuzzle() {
        puzzle.offsetX = Math.floor((COLS - puzzle.size) / 2);
        puzzle.offsetY = Math.floor((ROWS - puzzle.size) / 2);
        puzzle.grid = [];
        puzzle.solvedGrid = [];
        let count = 1;
        for (let r = 0; r < puzzle.size; r++) {
            puzzle.grid[r] = [];
            puzzle.solvedGrid[r] = [];
            for (let c = 0; c < puzzle.size; c++) {
                const value = count % (puzzle.size * puzzle.size);
                puzzle.grid[r][c] = value;
                puzzle.solvedGrid[r][c] = value;
                count++;
            }
        }
        puzzle.emptyTile = { r: puzzle.size - 1, c: puzzle.size - 1 };
        
        // Shuffle puzzle
        for (let i = 0; i < 100; i++) {
            const moves = [];
            if (puzzle.emptyTile.r > 0) moves.push({r: -1, c: 0});
            if (puzzle.emptyTile.r < puzzle.size - 1) moves.push({r: 1, c: 0});
            if (puzzle.emptyTile.c > 0) moves.push({r: 0, c: -1});
            if (puzzle.emptyTile.c < puzzle.size - 1) moves.push({r: 0, c: 1});
            const randomMove = moves[Math.floor(Math.random() * moves.length)];
            const tileToMove = { r: puzzle.emptyTile.r + randomMove.r, c: puzzle.emptyTile.c + randomMove.c };
            
            [puzzle.grid[tileToMove.r][tileToMove.c], puzzle.grid[puzzle.emptyTile.r][puzzle.emptyTile.c]] = 
            [puzzle.grid[puzzle.emptyTile.r][puzzle.emptyTile.c], puzzle.grid[tileToMove.r][tileToMove.c]];
            
            puzzle.emptyTile = tileToMove;
        }
    }

    function tryMovePuzzlePiece(player, dx, dy) {
        const targetX = player.x + dx;
        const targetY = player.y + dy;

        // Check if target is within puzzle area
        if (targetX >= puzzle.offsetX && targetX < puzzle.offsetX + puzzle.size &&
            targetY >= puzzle.offsetY && targetY < puzzle.offsetY + puzzle.size) {
            
            const puzzleC = targetX - puzzle.offsetX;
            const puzzleR = targetY - puzzle.offsetY;

            // Check if player is pushing towards the empty tile
            if (puzzle.emptyTile.r === puzzleR + dy && puzzle.emptyTile.c === puzzleC + dx) {
                [puzzle.grid[puzzleR][puzzleC], puzzle.grid[puzzle.emptyTile.r][puzzle.emptyTile.c]] = 
                [puzzle.grid[puzzle.emptyTile.r][puzzle.emptyTile.c], puzzle.grid[puzzleR][puzzleC]];
                
                puzzle.emptyTile = { r: puzzleR, c: puzzleC };
                moveEntity(player, dx, dy);
                return true;
            }
        }
        return false;
    }

    function checkPuzzleSolved() {
        for (let r = 0; r < puzzle.size; r++) {
            for (let c = 0; c < puzzle.size; c++) {
                if (puzzle.grid[r][c] !== puzzle.solvedGrid[r][c]) return false;
            }
        }
        return true;
    }

    function drawPuzzle() {
        ctx.save();
        ctx.font = `${TILE_SIZE}px sans-serif`;
        for (let r = 0; r < puzzle.size; r++) {
            for (let c = 0; c < puzzle.size; c++) {
                const tileValue = puzzle.grid[r][c];
                if (tileValue === 0) continue;
                
                const x = (puzzle.offsetX + c) * TILE_SIZE;
                const y = (puzzle.offsetY + r) * TILE_SIZE;
                
                ctx.fillStyle = '#4a5568';
                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                ctx.strokeStyle = '#2d3748';
                ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
                
                ctx.fillStyle = '#f7b733';
                ctx.fillText(tileValue, x + TILE_SIZE / 2, y + TILE_SIZE / 2);
            }
        }
        ctx.restore();
    }


    // --- Spu≈°tƒõn√≠ hry ---
    resetAndStartLobby();

</script>
</body>
</html>