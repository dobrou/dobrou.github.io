<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>√ötƒõk ban√°n≈Ø</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden; /* Zamezit jak√©mukoliv scrollov√°n√≠ */
        }
        body {
            font-family: 'Press-Start-2P', cursive;
            background-color: #1a202c;
            color: #f7fafc;
            display: flex;
            flex-direction: column; /* Uspo≈ô√°dat prvky pod sebe */
            justify-content: center;
            align-items: center;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            width: 100%;
            height: 100%;
            padding: 1rem;
            box-sizing: border-box;
        }
        .canvas-wrapper {
            flex-grow: 1; /* Nechat pl√°tno zabrat co nejv√≠ce m√≠sta */
            width: 100%;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 0; /* D≈Øle≈æit√© pro flexbox v nƒõkter√Ωch prohl√≠≈æeƒç√≠ch */
        }
        canvas {
            border-radius: 0.5rem;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            max-width: 100%;   /* Udr≈æet v kontejneru */
            max-height: 100%;  /* Udr≈æet v kontejneru */
            object-fit: contain; /* Zachovat pomƒõr stran */
        }
        .info-panel {
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            width: 100%;
            max-width: 1200px; /* Omezit ≈°√≠≈ôku panelu */
            min-height: 40px;
            font-size: 0.8rem; /* Zmen≈°en√© p√≠smo pro v√≠ce informac√≠ */
            padding: 0.5rem;
            background-color: #2d3748;
            border-radius: 0.5rem;
            flex-shrink: 0; /* Panel se nebude zmen≈°ovat */
        }
        .player-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: #4a5568;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
        }
        .modal {
            display: none; /* Skryto defaultnƒõ */
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #2d3748;
            padding: 2rem;
            border: 2px solid #4a5568;
            border-radius: 1rem;
            text-align: center;
            max-width: 90%;
            width: 500px;
        }
        .modal-content h2 {
            font-size: 1.75rem;
            margin-bottom: 1rem;
            color: #f7b733;
        }
        .modal-content p {
            font-size: 1rem;
            line-height: 1.5;
            margin-bottom: 1.5rem;
        }
        .modal-content button {
            background-color: #f7b733;
            color: #1a202c;
            border: none;
            padding: 0.75rem 1.5rem;
            font-family: 'Press Start 2P', cursive;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.3s;
            margin: 0.5rem;
        }
        .modal-content button:hover {
            background-color: #fccb00;
        }
    </style>
</head>
<body>

<div class="game-container">
    <h1 class="text-3xl text-yellow-400 flex-shrink-0">√ötƒõk ban√°n≈Ø</h1>
    <div id="infoPanel" class="info-panel"></div>
    <div class="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
    </div>
</div>

<div id="messageModal" class="modal">
    <div class="modal-content">
        <h2 id="modalTitle"></h2>
        <p id="modalText"></p>
        <button id="modalButton"></button>
    </div>
</div>

<script>
    // --- Nastaven√≠ hry ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const TILE_SIZE = 40;
    const COLS = 17;
    const ROWS = 13;
    canvas.width = COLS * TILE_SIZE;
    canvas.height = ROWS * TILE_SIZE;

    // --- Hern√≠ stavy a objekty ---
    const TILES = { EMPTY: 0, INDESTRUCTIBLE: 1, DESTRUCTIBLE: 2 };
    let levelMap = [], bombs = [], explosions = [], enemies = [], powerUps = [], lasers = [], bossProjectiles = [];
    let players = [];
    let boss = null;
    let gameState = { currentLevel: 1, enemiesRemaining: 0, isPaused: false, killCount: 0, gameActive: false, inputCooldown: 0 };

    const PLAYER_CONFIG = [
        { id: 'keyboard1', symbol: 'ü•ï', start: { x: COLS - 2, y: 1 }, controls: { type: 'keyboard', up: 'arrowup', down: 'arrowdown', left: 'arrowleft', right: 'arrowright', bomb: ' ' } },
        { id: 'keyboard2', symbol: 'ü•í', start: { x: COLS - 2, y: ROWS - 2 }, controls: { type: 'keyboard', up: 'w', down: 's', left: 'a', right: 'd', bomb: 'q' } },
        { id: 'gamepad0', symbol: 'üçå', start: { x: 1, y: 1 }, controls: { type: 'gamepad' } },
        { id: 'gamepad1', symbol: 'üçÜ', start: { x: 1, y: ROWS - 2 }, controls: { type: 'gamepad' } }
    ];
    let keysPressed = {};
    let cheatBuffer = "";
    
    const powerUpTypes = {
        range: { symbol: 'üî•' }, extra_bomb: { symbol: 'üí£' }, walk_walls: { symbol: 'üí®' },
        walk_bombs: { symbol: 'üõ°Ô∏è' }, kick_bomb: { symbol: 'üëü' }, speed: { symbol: 'üèÉ'},
        extra_life: { symbol: '‚ù§Ô∏è' }, wall_destroyer: { symbol: 'üí•' }
    };
    const allPowerUpTypes = Object.keys(powerUpTypes);
    const levelDesigns = {
        1: { name: "D≈æungle I", bgColor: '#4CAF50', enemyType: 'üêµ', enemyName: "Opice", enemyCount: 3, wallType: 'üå≥', destructibleWallType: 'üåø' },
        2: { name: "D≈æungle II", bgColor: '#388E3C', enemyType: 'üêç', enemyName: "Hadi", enemyCount: 4, wallType: 'üå≥', destructibleWallType: 'üåø' },
        3: { name: "Hory I", bgColor: '#a0d2eb', enemyType: 'üßä', enemyName: "Rampouchy", enemyCount: 4, wallType: '‚õ∞Ô∏è', destructibleWallType: '‚ùÑÔ∏è' },
        4: { name: "Hory II", bgColor: '#81c7e8', enemyType: 'üßä', enemyName: "Rampouchy", enemyCount: 5, wallType: '‚õ∞Ô∏è', destructibleWallType: '‚ùÑÔ∏è' },
        5: { name: "Hrad - 1. patro", bgColor: '#6c757d', enemyType: 'üëª', enemyName: "Duchov√©", enemyCount: 5, wallType: 'üß±', destructibleWallType: 'üõ¢Ô∏è' },
        6: { name: "Hrad - 2. patro", bgColor: '#495057', enemyType: 'üëª', enemyName: "Duchov√©", enemyCount: 6, wallType: 'üß±', destructibleWallType: 'üõ¢Ô∏è' },
        7: { name: "Hrad - 3. patro", bgColor: '#343a40', enemyType: 'üëª', enemyName: "Duchov√©", enemyCount: 7, wallType: 'üß±', destructibleWallType: 'üõ¢Ô∏è' },
        8: { name: "Ar√©na Kr√°le Opic", bgColor: '#d32f2f', enemyType: '', enemyName: "Kr√°l Opic", enemyCount: 1, wallType: 'üß±', destructibleWallType: 'üõ¢Ô∏è', isBossLevel: true },
        9: { name: "Hrad - Tr≈Ønn√≠ s√°l", bgColor: '#212121', enemyCount: 0, isFinalLevel: true }
    };

    function createEntity(config) {
        const entity = { ...config };
        entity.x = config.start.x;
        entity.y = config.start.y;
        entity.px = entity.x * TILE_SIZE + TILE_SIZE / 2;
        entity.py = entity.y * TILE_SIZE + TILE_SIZE / 2;
        entity.isMoving = false;
        entity.targetX = entity.x;
        entity.targetY = entity.y;
        entity.speed = 4;
        entity.isAlive = true;
        return entity;
    }

    function createPlayer(config) {
        const player = createEntity(config);
        player.lives = 5; // Start with 5 lives
        player.bombsMax = 1;
        player.bombRange = 1;
        player.canWalkThroughWalls = false;
        player.canWalkThroughBombs = false;
        player.canKickBomb = false;
        player.canDestroyWalls = false;
        player.isHit = false;
        player.hitTimer = 0;
        player.bombCooldown = 0;
        return player;
    }

    // --- Pomocn√© a UI funkce ---
    function getTile(x, y) {
        if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return TILES.INDESTRUCTIBLE;
        return levelMap[y][x];
    }
    function isBombAt(x, y) { return bombs.some(bomb => bomb.x === x && bomb.y === y); }

    function showModal(title, text, buttonText, onButtonClick) {
        gameState.isPaused = true;
        const modal = document.getElementById('messageModal');
        document.getElementById('modalTitle').innerText = title;
        document.getElementById('modalText').innerText = text;
        const button = document.getElementById('modalButton');
        button.innerText = buttonText;
        button.onclick = () => {
            modal.style.display = 'none';
            if (onButtonClick) onButtonClick();
        };
        modal.style.display = 'flex';
    }
    
    function updateInfoPanel() {
        const infoPanel = document.getElementById('infoPanel');
        infoPanel.innerHTML = '';
        if (!gameState.gameActive) return;
        players.forEach((p, i) => {
            const playerDiv = document.createElement('div');
            playerDiv.className = 'player-info';
            const livesHTML = p.symbol.repeat(p.lives);
            
            let powerUpsHTML = `<div class="flex items-center ml-2 border-l-2 border-gray-500 pl-2">`;
            powerUpsHTML += `<span>${powerUpTypes.range.symbol.repeat(p.bombRange)}</span>`;
            powerUpsHTML += `<span class="ml-2">${powerUpTypes.extra_bomb.symbol.repeat(p.bombsMax)}</span>`;
            if (p.canKickBomb) powerUpsHTML += `<span class="ml-2">${powerUpTypes.kick_bomb.symbol}</span>`;
            if (p.canWalkThroughWalls) powerUpsHTML += `<span class="ml-2">${powerUpTypes.walk_walls.symbol}</span>`;
            if (p.canWalkThroughBombs) powerUpsHTML += `<span class="ml-2">${powerUpTypes.walk_bombs.symbol}</span>`;
            if (p.speed > 4) powerUpsHTML += `<span class="ml-2">${powerUpTypes.speed.symbol}</span>`;
            if (p.canDestroyWalls) powerUpsHTML += `<span class="ml-2">${powerUpTypes.wall_destroyer.symbol}</span>`;
            powerUpsHTML += `</div>`;

            playerDiv.innerHTML = `<span>Hr√°ƒç ${i+1}:</span> <span>${livesHTML}</span> ${powerUpsHTML}`;
            infoPanel.appendChild(playerDiv);
        });
        if (boss && boss.isAlive) {
            const bossDiv = document.createElement('div');
            bossDiv.className = 'player-info';
            bossDiv.innerHTML = `<span>BOSS:</span> <span class="text-red-500">${'‚ù§Ô∏è'.repeat(boss.hp)}</span>`;
            infoPanel.appendChild(bossDiv);
        }
    }

    // --- Generov√°n√≠ levelu ---
    function generateLevel() {
        levelMap = Array.from({ length: ROWS }, () => Array(COLS).fill(TILES.EMPTY));
        for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) {
            if (y === 0 || y === ROWS - 1 || x === 0 || x === COLS - 1 || (y % 2 === 0 && x % 2 === 0)) {
                levelMap[y][x] = TILES.INDESTRUCTIBLE;
            }
        }
        let destructibleWalls = [];
        if (!levelDesigns[gameState.currentLevel].isBossLevel && !levelDesigns[gameState.currentLevel].isFinalLevel) {
            for (let y = 1; y < ROWS - 1; y++) {
                for (let x = 1; x < COLS - 1; x++) {
                    const isStartArea = PLAYER_CONFIG.some(p => Math.abs(p.start.x - x) < 2 && Math.abs(p.start.y - y) < 2);
                    if (levelMap[y][x] === TILES.EMPTY && !isStartArea) {
                        if(Math.random() > 0.2) {
                            levelMap[y][x] = TILES.DESTRUCTIBLE;
                            destructibleWalls.push({x, y});
                        }
                    }
                }
            }
            const numPowerUps = Math.min(4, destructibleWalls.length);
            for(let i = 0; i < numPowerUps; i++) {
                const powerUpKey = allPowerUpTypes[Math.floor(Math.random() * allPowerUpTypes.length)];
                const wallIndex = Math.floor(Math.random() * destructibleWalls.length);
                const wall = destructibleWalls.splice(wallIndex, 1)[0];
                powerUps.push({x: wall.x, y: wall.y, type: powerUpKey, symbol: powerUpTypes[powerUpKey].symbol});
            }
        }
    }

    function spawnEntities() {
        const levelData = levelDesigns[gameState.currentLevel];
        gameState.enemiesRemaining = levelData.enemyCount;
        enemies = [];
        boss = null;
        lasers = [];
        bossProjectiles = [];

        if (levelData.isBossLevel) {
            boss = createEntity({start: {x: Math.floor(COLS / 2), y: Math.floor(ROWS / 2)}});
            boss.symbol = 'ü¶ç';
            boss.hp = 10;
            boss.isHit = false;
            boss.hitTimer = 0;
            boss.attackTimer = 180;
            boss.moveCounter = 120;
            gameState.enemiesRemaining = 1;
        } else if (levelData.enemyCount > 0) {
            for (let i = 0; i < levelData.enemyCount; i++) {
                let placed = false;
                while (!placed) {
                    const x = Math.floor(Math.random() * (COLS - 2)) + 1;
                    const y = Math.floor(Math.random() * (ROWS - 2)) + 1;
                    const isTooClose = PLAYER_CONFIG.some(p => (Math.abs(p.start.x - x) + Math.abs(p.start.y - y)) < 9);
                    if (getTile(x, y) === TILES.EMPTY && !isTooClose) {
                        const enemy = createEntity({start: {x, y}});
                        enemy.type = levelData.enemyType;
                        enemy.moveCounter = 0;
                        enemies.push(enemy);
                        placed = true;
                    }
                }
            }
        }
    }

    function initializeLevel(level) {
        gameState.isPaused = false;
        gameState.currentLevel = level;
        players.forEach(p => {
            p.x = p.start.x; p.y = p.start.y;
            p.px = p.x * TILE_SIZE + TILE_SIZE / 2;
            p.py = p.y * TILE_SIZE + TILE_SIZE / 2;
            p.isMoving = false;
            // Reset temporary power-ups
            p.canWalkThroughWalls = false;
            p.canWalkThroughBombs = false;
            p.canKickBomb = false;
            p.canDestroyWalls = false;
            p.speed = 4;
        });
        bombs = []; explosions = []; powerUps = [];
        generateLevel();
        spawnEntities();
        updateInfoPanel();
    }
    
    function resetAndStartLobby() {
        gameState.gameActive = false;
        gameState.isPaused = false;
        gameState.killCount = 0;
        players = [];
        initializeLevel(1);
        gameLoop();
    }

    // --- Hern√≠ smyƒçka ---
    function gameLoop() {
        if (gameState.inputCooldown > 0) gameState.inputCooldown--;
        handleInputs();
        if (gameState.gameActive && !gameState.isPaused) {
            update();
        }
        draw();
        requestAnimationFrame(gameLoop);
    }

    // --- Update logika ---
    function update() {
        updatePositions();
        players.forEach(p => {
            if (p.bombCooldown > 0) p.bombCooldown--;
            if (p.isHit) {
                p.hitTimer--;
                if (p.hitTimer <= 0) p.isHit = false;
            }
        });
        moveEnemies();
        updateBombs();
        if (boss && boss.isAlive) updateBoss();
        lasers = lasers.filter(l => --l.timer > 0);
        updateBossProjectiles();
        checkCollisions();
    }
    
    function updatePositions() {
        const allEntities = [...players, ...enemies, boss].filter(e => e);
        allEntities.forEach(entity => {
            if (!entity.isMoving) return;
            const targetPX = entity.targetX * TILE_SIZE + TILE_SIZE / 2;
            const targetPY = entity.targetY * TILE_SIZE + TILE_SIZE / 2;
            const dx = targetPX - entity.px;
            const dy = targetPY - entity.py;
            
            if (Math.abs(dx) < entity.speed && Math.abs(dy) < entity.speed) {
                entity.px = targetPX;
                entity.py = targetPY;
                entity.x = entity.targetX;
                entity.y = entity.targetY;
                entity.isMoving = false;
            } else {
                entity.px += Math.sign(dx) * entity.speed;
                entity.py += Math.sign(dy) * entity.speed;
            }
        });
    }

    function moveEnemies() {
        enemies.forEach(enemy => {
            if (enemy.isMoving) return;
            enemy.moveCounter--;
            if (enemy.moveCounter <= 0) {
                const directions = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];
                const dir = directions[Math.floor(Math.random() * directions.length)];
                moveEntity(enemy, dir.x, dir.y);
                enemy.moveCounter = Math.floor(Math.random() * 60) + 30;
            }
        });
    }

    function updateBoss() {
        if (boss.isHit) {
            boss.hitTimer--;
            if (boss.hitTimer <= 0) boss.isHit = false;
        }
        
        if (!boss.isMoving) {
            boss.moveCounter--;
            if (boss.moveCounter <= 0) {
                const directions = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];
                const dir = directions[Math.floor(Math.random() * directions.length)];
                moveEntity(boss, dir.x, dir.y);
                boss.moveCounter = 90 + Math.random() * 60;
            }
        }

        boss.attackTimer--;
        if (boss.attackTimer <= 0) {
            const activePlayers = players.filter(p => p.isAlive);
            if (activePlayers.length > 0) {
                const targetPlayer = activePlayers[Math.floor(Math.random() * activePlayers.length)];
                if (Math.random() > 0.5) { // Laser
                    const isHorizontal = Math.random() > 0.5;
                    const line = isHorizontal ? targetPlayer.y : targetPlayer.x;
                    lasers.push({ isHorizontal, line, timer: 120, state: 'warning' });
                } else { // Kokosov√° bomba
                    bossProjectiles.push({ x: targetPlayer.x, y: targetPlayer.y, timer: 90, state: 'warning' });
                }
            }
            boss.attackTimer = 120 + Math.random() * 60;
        }
        lasers.forEach(l => { if (l.state === 'warning' && l.timer < 60) l.state = 'firing'; });
    }

    function updateBossProjectiles() {
        bossProjectiles.forEach(proj => {
            proj.timer--;
            if (proj.state === 'warning' && proj.timer <= 0) {
                proj.state = 'exploding';
                proj.timer = 20;
                createExplosion(proj.x, proj.y, 1);
            }
        });
        bossProjectiles = bossProjectiles.filter(p => p.timer > 0);
    }

    function updateBombs() {
        explosions = explosions.filter(e => --e.timer > 0);
        bombs.forEach(bomb => {
            if (bomb.isKicked) {
                bomb.kickTimer--;
                if (bomb.kickTimer <= 0) {
                    bomb.kickTimer = 8;
                    const nextX = bomb.x + bomb.vx;
                    const nextY = bomb.y + bomb.vy;
                    if (getTile(nextX, nextY) === TILES.EMPTY && !isBombAt(nextX, nextY)) {
                        bomb.x = nextX;
                        bomb.y = nextY;
                    } else {
                        bomb.isKicked = false;
                    }
                }
            }
            bomb.timer--;
            if (bomb.timer <= 0 && !bomb.exploded) {
                triggerExplosion(bomb);
            }
        });
        bombs = bombs.filter(bomb => !bomb.exploded);
    }

    function triggerExplosion(bomb) {
        if (bomb.exploded) return;
        bomb.exploded = true;
        const owner = players.find(p => p.id === bomb.ownerId);
        createExplosion(bomb.x, bomb.y, owner ? owner.bombRange : 1, owner);
    }

    function createExplosion(x, y, range, owner) {
        const explosionTiles = [{ x, y, timer: 20 }];
        const directions = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];
        directions.forEach(dir => {
            for (let i = 1; i <= range; i++) {
                const ex = x + dir.x * i;
                const ey = y + dir.y * i;
                const tile = getTile(ex, ey);

                if (tile === TILES.INDESTRUCTIBLE) {
                    if (owner && owner.canDestroyWalls) {
                        levelMap[ey][ex] = TILES.EMPTY;
                        const powerUpKey = allPowerUpTypes[Math.floor(Math.random() * allPowerUpTypes.length)];
                        powerUps.push({x: ex, y: ey, type: powerUpKey, symbol: powerUpTypes[powerUpKey].symbol});
                    }
                    break;
                }
                
                explosionTiles.push({ x: ex, y: ey, timer: 20 });
                bombs.forEach(b => { if(b.x === ex && b.y === ey) triggerExplosion(b); });
                if (tile === TILES.DESTRUCTIBLE) {
                    levelMap[ey][ex] = TILES.EMPTY;
                    break;
                }
            }
        });
        explosions.push(...explosionTiles);
    }

    function checkCollisions() {
        const levelData = levelDesigns[gameState.currentLevel];
        const currentEnemyName = levelData.enemyName ? levelData.enemyName.slice(0, -1).toLowerCase() : "";

        players.forEach((p) => {
            if (!p.isAlive || p.isHit) return;
            let hit = false;
            if (currentEnemyName) {
                enemies.forEach(enemy => { if (enemy.x === p.x && enemy.y === p.y) hit = `Chytil tƒõ ${currentEnemyName}!`; });
            }
            explosions.forEach(exp => { if (exp.x === p.x && exp.y === p.y) hit = "Zas√°hla tƒõ exploze!"; });
            lasers.forEach(l => {
                if (l.state === 'firing') {
                    if ((l.isHorizontal && l.line === p.y) || (!l.isHorizontal && l.line === p.x)) {
                        hit = "Zas√°hl tƒõ laser!";
                    }
                }
            });
            if (hit) handlePlayerHit(p, hit);
        });

        explosions.forEach(exp => {
            enemies = enemies.filter(enemy => {
                if (enemy.x === exp.x && enemy.y === exp.y) {
                    gameState.enemiesRemaining--;
                    gameState.killCount++;
                    if (gameState.killCount > 0 && gameState.killCount % 18 === 0) {
                        players.forEach(p => { if(p.isAlive) p.lives++; });
                    }
                    updateInfoPanel();
                    return false;
                }
                return true;
            });
            if (boss && boss.isAlive && !boss.isHit && exp.x === boss.x && exp.y === boss.y) {
                boss.hp--;
                boss.isHit = true;
                boss.hitTimer = 30;
                if (boss.hp <= 0) {
                    boss.isAlive = false;
                    gameState.enemiesRemaining = 0;
                }
                updateInfoPanel();
            }
        });
        
        players.forEach(p => {
             powerUps.forEach((powerUp, index) => {
                if(getTile(powerUp.x, powerUp.y) === TILES.EMPTY && p.x === powerUp.x && p.y === powerUp.y) {
                    switch(powerUp.type) {
                        case 'range': p.bombRange++; break;
                        case 'extra_bomb': p.bombsMax++; break;
                        case 'walk_walls': p.canWalkThroughWalls = true; break;
                        case 'walk_bombs': p.canWalkThroughBombs = true; break;
                        case 'kick_bomb': p.canKickBomb = true; break;
                        case 'speed': p.speed += 2; break;
                        case 'extra_life': p.lives++; break;
                        case 'wall_destroyer': p.canDestroyWalls = true; break;
                    }
                    powerUps.splice(index, 1);
                    updateInfoPanel();
                }
            });
        });

        if (gameState.gameActive && gameState.enemiesRemaining <= 0 && !levelData.isFinalLevel) {
            levelComplete();
        }

        if (levelData.isFinalLevel && !gameState.isPaused) {
            const kingX = Math.floor(COLS / 2);
            const kingY = 2;
            if (players.some(p => p.isAlive && p.x === kingX && p.y === kingY)) {
                showFinalScene();
            }
        }
    }
    
    // --- Stavy hr√°ƒçe a postup ---
    function handlePlayerHit(player, reason) {
        if (!player.isAlive) return;
        player.lives--;
        if (player.lives <= 0) {
            player.isAlive = false;
        } else {
            player.isHit = true;
            player.hitTimer = 120;
            player.x = player.start.x; player.y = player.start.y;
            player.px = player.x * TILE_SIZE + TILE_SIZE / 2;
            player.py = player.y * TILE_SIZE + TILE_SIZE / 2;
            player.isMoving = false;
        }
        updateInfoPanel();
        
        if (players.every(pl => !pl.isAlive)) {
            gameOver(reason);
        }
    }

    function gameOver(reason) {
        gameState.gameActive = false;
        showModal("Konec hry!", reason, "Hr√°t znovu?", resetAndStartLobby);
    }

    function levelComplete() {
        gameState.isPaused = true;
        const nextLevel = gameState.currentLevel + 1;
        if (levelDesigns[nextLevel]) {
             showModal("Level dokonƒçen!", "Poraƒè si s dal≈°√≠ v√Ωzvou.", "Dal≈°√≠ level", () => initializeLevel(nextLevel));
        }
    }

    function showFinalScene() {
        gameState.isPaused = true;
        const dialogue = "Kr√°l ban√°n≈Ø üëë: 'Skvƒõl√° pr√°ce, ovocn√≠ hrdinov√©! Jste hodni svobody!'";
        showModal("Setk√°n√≠ s kr√°lem", dialogue, "Hr√°t znovu?", resetAndStartLobby);
    }

    // --- Kreslen√≠ ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const levelData = levelDesigns[gameState.currentLevel];
        canvas.style.backgroundColor = levelData.bgColor;

        ctx.font = `${TILE_SIZE * 0.8}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        ctx.fillStyle = 'black';
        for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) {
            const tile = getTile(x, y);
            let symbol = '';
            if (tile === TILES.INDESTRUCTIBLE) symbol = levelData.wallType;
            if (tile === TILES.DESTRUCTIBLE) symbol = levelData.destructibleWallType;
            if (symbol) ctx.fillText(symbol, x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
        }
        
        if (!gameState.gameActive) {
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(0, canvas.height / 2 - 30, canvas.width, 60);
            ctx.fillStyle = "white";
            ctx.font = "20px 'Press Start 2P'";
            ctx.fillText("Stisknƒõte kl√°vesu nebo tlaƒç√≠tko", canvas.width / 2, canvas.height / 2 - 10);
            ctx.fillText("pro p≈ôipojen√≠ do hry!", canvas.width / 2, canvas.height / 2 + 20);
            return;
        }
        
        powerUps.forEach(p => { if(getTile(p.x, p.y) === TILES.EMPTY) ctx.fillText(p.symbol, p.x * TILE_SIZE + TILE_SIZE / 2, p.y * TILE_SIZE + TILE_SIZE / 2); });
        bombs.forEach(bomb => ctx.fillText('üí£', bomb.x * TILE_SIZE + TILE_SIZE / 2, bomb.y * TILE_SIZE + TILE_SIZE / 2));
        
        explosions.forEach(exp => {
            const centerX = exp.x * TILE_SIZE + TILE_SIZE / 2;
            const centerY = exp.y * TILE_SIZE + TILE_SIZE / 2;
            const progress = exp.timer / 20;
            const grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, TILE_SIZE / 2 * progress);
            grad.addColorStop(0, 'white'); grad.addColorStop(0.5, 'yellow'); grad.addColorStop(1, 'rgba(255, 165, 0, 0.7)');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(centerX, centerY, TILE_SIZE / 2 * progress, 0, 2 * Math.PI); ctx.fill();
        });

        drawLasers();
        drawBossProjectiles();

        players.forEach(p => {
            if (p.isAlive) {
                ctx.save();
                ctx.globalAlpha = (p.isHit && Math.floor(p.hitTimer / 10) % 2 === 0) ? 0.5 : 1.0;
                ctx.fillStyle = 'black';
                ctx.fillText(p.symbol, p.px, p.py);
                ctx.restore();
            }
        });
        
        ctx.fillStyle = 'black';
        enemies.forEach(enemy => ctx.fillText(enemy.type, enemy.px, enemy.py));
        if (boss && boss.isAlive) {
            ctx.save();
            ctx.globalAlpha = (boss.isHit && Math.floor(boss.hitTimer / 10) % 2 === 0) ? 0.5 : 1.0;
            ctx.font = `${TILE_SIZE * 1.5}px sans-serif`;
            ctx.fillText(boss.symbol, boss.px, boss.py);
            ctx.restore();
        }

        if (levelData.isFinalLevel) {
            ctx.font = `${TILE_SIZE * 2}px sans-serif`;
            ctx.fillText('üëë', canvas.width / 2, TILE_SIZE * 2);
        }
    }

    function drawLasers() {
        lasers.forEach(l => {
            if (l.state === 'warning') {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                if (l.isHorizontal) ctx.fillRect(0, l.line * TILE_SIZE, canvas.width, TILE_SIZE);
                else ctx.fillRect(l.line * TILE_SIZE, 0, TILE_SIZE, canvas.height);
            } else if (l.state === 'firing') {
                ctx.fillStyle = 'red';
                if (l.isHorizontal) ctx.fillRect(0, l.line * TILE_SIZE, canvas.width, TILE_SIZE);
                else ctx.fillRect(l.line * TILE_SIZE, 0, TILE_SIZE, canvas.height);
            }
        });
    }

    function drawBossProjectiles() {
        bossProjectiles.forEach(p => {
            if (p.state === 'warning') {
                ctx.fillStyle = 'rgba(255, 165, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(p.x * TILE_SIZE + TILE_SIZE / 2, p.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.fillText('ü••', p.x * TILE_SIZE + TILE_SIZE / 2, p.y * TILE_SIZE + TILE_SIZE / 2);
            }
        });
    }

    // --- Ovl√°d√°n√≠ ---
    let touchPlayer = null;
    let touchIdentifier = null;
    let touchStartX = 0, touchStartY = 0;
    let joystickActive = false;
    let touchDirection = { x: 0, y: 0 };
    let touchInputDetected = false;

    function placeBomb(player) {
        if (!player || !player.isAlive || player.bombCooldown > 0 || gameState.inputCooldown > 0) return;
        if (bombs.filter(b => b.ownerId === player.id).length < player.bombsMax && !isBombAt(player.x, player.y)) {
            bombs.push({ x: player.x, y: player.y, timer: 120, exploded: false, ownerId: player.id, isKicked: false, vx: 0, vy: 0, kickTimer: 0 });
            player.bombCooldown = 15;
        }
    }

    function moveEntity(entity, dx, dy) {
        if (!entity || !entity.isAlive || entity.isMoving) return;
        const newX = entity.x + dx;
        const newY = entity.y + dy;
        const targetTile = getTile(newX, newY);
        const bombAtTarget = bombs.find(b => b.x === newX && b.y === newY);

        if (entity.canKickBomb && bombAtTarget && !bombAtTarget.isKicked) {
            bombAtTarget.isKicked = true;
            bombAtTarget.vx = dx;
            bombAtTarget.vy = dy;
            bombAtTarget.kickTimer = 8;
            return;
        }

        let canMove = false;
        if (targetTile === TILES.EMPTY || (targetTile === TILES.DESTRUCTIBLE && entity.canWalkThroughWalls)) canMove = true;
        if (bombAtTarget && !entity.canWalkThroughBombs) canMove = false;
        if (canMove) {
            entity.targetX = newX;
            entity.targetY = newY;
            entity.isMoving = true;
        }
    }

    function handleInputs() {
        // Cheaty
        const lastKey = keysPressed.lastKey;
        if (lastKey) {
            cheatBuffer += lastKey;
            keysPressed.lastKey = null;
            if (cheatBuffer.length > 10) cheatBuffer = cheatBuffer.slice(-10);
            const match = cheatBuffer.match(/LEVEL(\d+)/);
            if (match) {
                const levelNum = parseInt(match[1]);
                if (levelDesigns[levelNum]) {
                    if (!gameState.gameActive) {
                        players.push(createPlayer(PLAYER_CONFIG[2]));
                        gameState.gameActive = true;
                    }
                    initializeLevel(levelNum);
                    cheatBuffer = "";
                }
            }
        }

        // Potvrzen√≠ modalu
        if (gameState.isPaused) {
            const confirmKeyPressed = keysPressed['enter'];
            let bombButtonPressed = false;
            if (keysPressed[' '] || keysPressed['q']) bombButtonPressed = true;
            
            const gamepads = navigator.getGamepads();
            for (const gp of gamepads) {
                if (gp && gp.buttons[0].pressed) {
                    bombButtonPressed = true;
                    break;
                }
            }

            if (confirmKeyPressed || bombButtonPressed) {
                const modalButton = document.getElementById('modalButton');
                if (modalButton && modalButton.offsetParent !== null) {
                    if (!modalButton.disabled) {
                         modalButton.click();
                         modalButton.disabled = true;
                         gameState.inputCooldown = 15;
                         setTimeout(() => { modalButton.disabled = false; }, 500);
                    }
                }
            }
            return;
        }

        // P≈ôid√°n√≠ nov√Ωch hr√°ƒç≈Ø
        if (players.length < 4) {
            const assignedKeyboardIds = players.filter(p => p.controls.type === 'keyboard').map(p => p.id);
            const assignedGamepadIndices = players.filter(p => p.controls.type === 'gamepad' && typeof p.controls.index !== 'undefined').map(p => p.controls.index);
            const assignedTouch = players.some(p => p.controls.type === 'touch');

            if (touchInputDetected && !assignedTouch) {
                const availableConfig = PLAYER_CONFIG.find(c => !players.some(p => p.id === c.id));
                if (availableConfig) {
                    const newPlayer = createPlayer(availableConfig);
                    newPlayer.controls.type = 'touch';
                    touchPlayer = newPlayer;
                    players.push(newPlayer);
                    if (!gameState.gameActive) gameState.gameActive = true;
                    updateInfoPanel();
                }
            }
            for (const key in keysPressed) {
                if (keysPressed[key]) {
                    const config = PLAYER_CONFIG.find(c => c.controls.type === 'keyboard' && Object.values(c.controls).includes(key));
                    if (config && !assignedKeyboardIds.includes(config.id)) {
                        players.push(createPlayer(config));
                        if (!gameState.gameActive) gameState.gameActive = true;
                        updateInfoPanel();
                    }
                }
            }
            const gamepads = navigator.getGamepads();
            for (const gp of gamepads) {
                if (!gp || assignedGamepadIndices.includes(gp.index)) continue;
                const isActive = gp.buttons.some(b => b.pressed) || gp.axes.some(a => Math.abs(a) > 0.5);
                if (isActive) {
                     const assignedGamepadConfigIds = players.filter(p => p.controls.type === 'gamepad').map(p => p.id);
                     const availableConfig = PLAYER_CONFIG.find(c => c.controls.type === 'gamepad' && !assignedGamepadConfigIds.includes(c.id));
                     if (availableConfig) {
                         const newPlayer = createPlayer(availableConfig);
                         newPlayer.controls.index = gp.index;
                         players.push(newPlayer);
                         if (!gameState.gameActive) gameState.gameActive = true;
                         updateInfoPanel();
                     }
                }
            }
        }

        // Ovl√°d√°n√≠ aktivn√≠ch hr√°ƒç≈Ø
        players.forEach(p => {
            if (!p.isAlive) return;
            if (p.controls.type === 'keyboard') {
                if (keysPressed[p.controls.up]) moveEntity(p, 0, -1);
                else if (keysPressed[p.controls.down]) moveEntity(p, 0, 1);
                else if (keysPressed[p.controls.left]) moveEntity(p, -1, 0);
                else if (keysPressed[p.controls.right]) moveEntity(p, 1, 0);
                if (keysPressed[p.controls.bomb]) placeBomb(p);
            } else if (p.controls.type === 'gamepad') {
                if (typeof p.controls.index === 'undefined') return;
                const gp = navigator.getGamepads()[p.controls.index];
                if (!gp) return;
                if (gp.buttons[0].pressed) placeBomb(p);
                const deadzone = 0.5;
                const dx = gp.axes[0];
                const dy = gp.axes[1];
                if (Math.abs(dx) > deadzone) moveEntity(p, Math.sign(dx), 0);
                else if (Math.abs(dy) > deadzone) moveEntity(p, 0, Math.sign(dy));
            } else if (p.controls.type === 'touch') {
                if (touchDirection.x !== 0 || touchDirection.y !== 0) {
                    moveEntity(p, touchDirection.x, touchDirection.y);
                }
            }
        });
    }

    window.addEventListener('keydown', (e) => { 
        const key = e.key.toLowerCase();
        keysPressed[key] = true; 
        keysPressed.lastKey = e.key.toUpperCase();
    });
    window.addEventListener('keyup', (e) => { keysPressed[e.key.toLowerCase()] = false; });

    // --- Dotykov√© ovl√°d√°n√≠ ---
    window.addEventListener('touchstart', (e) => {
        e.preventDefault();
        touchInputDetected = true;

        if (e.touches.length >= 2) {
            if (touchPlayer) placeBomb(touchPlayer);
            return;
        }
        
        const touch = e.changedTouches[0];
        if (!joystickActive) {
            joystickActive = true;
            touchIdentifier = touch.identifier;
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        }
    }, { passive: false });

    window.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!joystickActive) return;
        let touch = null;
        for (let t of e.changedTouches) {
            if (t.identifier === touchIdentifier) {
                touch = t;
                break;
            }
        }
        if (!touch) return;

        const deltaX = touch.clientX - touchStartX;
        const deltaY = touch.clientY - touchStartY;
        
        const threshold = 20;
        touchDirection = { x: 0, y: 0 };
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
            if (deltaX > threshold) touchDirection.x = 1;
            else if (deltaX < -threshold) touchDirection.x = -1;
        } else {
            if (deltaY > threshold) touchDirection.y = 1;
            else if (deltaY < -threshold) touchDirection.y = -1;
        }
    }, { passive: false });

    window.addEventListener('touchend', (e) => {
        e.preventDefault();
        for (let t of e.changedTouches) {
            if (t.identifier === touchIdentifier) {
                joystickActive = false;
                touchIdentifier = null;
                touchDirection = { x: 0, y: 0 };
                break;
            }
        }
    });


    // --- Spu≈°tƒõn√≠ hry ---
    resetAndStartLobby();

</script>
</body>
</html>
