<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√ötƒõk ban√°n≈Ø</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Press-Start-2P', cursive;
            background-color: #1a202c;
            color: #f7fafc;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            width: 95vw; /* Vyu≈æ√≠t v√≠ce m√≠sta na ≈°√≠≈ôku */
            max-width: 1400px; /* Maxim√°ln√≠ ≈°√≠≈ôka pro velk√© obrazovky */
        }
        canvas {
            border-radius: 0.5rem;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            width: 100%; /* Pl√°tno se p≈ôizp≈Øsob√≠ kontejneru */
            height: auto;
        }
        .info-panel {
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            width: 100%;
            min-height: 40px;
            font-size: 0.9rem;
            padding: 0.5rem;
            background-color: #2d3748;
            border-radius: 0.5rem;
        }
        .player-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .modal {
            display: none; /* Skryto defaultnƒõ */
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #2d3748;
            padding: 2rem;
            border: 2px solid #4a5568;
            border-radius: 1rem;
            text-align: center;
            max-width: 90%;
            width: 500px;
        }
        .modal-content h2 {
            font-size: 1.75rem;
            margin-bottom: 1rem;
            color: #f7b733;
        }
        .modal-content p {
            font-size: 1rem;
            line-height: 1.5;
            margin-bottom: 1.5rem;
        }
        .modal-content button {
            background-color: #f7b733;
            color: #1a202c;
            border: none;
            padding: 0.75rem 1.5rem;
            font-family: 'Press Start 2P', cursive;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.3s;
            margin: 0.5rem;
        }
        .modal-content button:hover {
            background-color: #fccb00;
        }
    </style>
</head>
<body>

<div class="game-container">
    <h1 class="text-3xl mb-4 text-yellow-400">√ötƒõk ban√°n≈Ø</h1>
    <div id="infoPanel" class="info-panel"></div>
    <canvas id="gameCanvas"></canvas>
</div>

<div id="messageModal" class="modal">
    <div class="modal-content">
        <h2 id="modalTitle"></h2>
        <p id="modalText"></p>
        <button id="modalButton"></button>
    </div>
</div>

<script>
    // --- Nastaven√≠ hry ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const TILE_SIZE = 40;
    const COLS = 17;
    const ROWS = 13;
    canvas.width = COLS * TILE_SIZE;
    canvas.height = ROWS * TILE_SIZE;

    // --- Hern√≠ stavy a objekty ---
    const TILES = { EMPTY: 0, INDESTRUCTIBLE: 1, DESTRUCTIBLE: 2 };
    let levelMap = [], bombs = [], explosions = [], enemies = [], powerUps = [];
    let players = [];
    let gameState = { currentLevel: 1, enemiesRemaining: 0, isPaused: false, killCount: 0, gameActive: false };

    const PLAYER_CONFIG = [
        { id: 'keyboard1', symbol: 'üçå', start: { x: 1, y: 1 }, controls: { type: 'keyboard', up: 'arrowup', down: 'arrowdown', left: 'arrowleft', right: 'arrowright', bomb: ' ' } },
        { id: 'keyboard2', symbol: 'ü•í', start: { x: COLS - 2, y: ROWS - 2 }, controls: { type: 'keyboard', up: 'w', down: 's', left: 'a', right: 'd', bomb: 'q' } },
        { id: 'gamepad0', symbol: 'ü•ï', start: { x: COLS - 2, y: 1 }, controls: { type: 'gamepad' } },
        { id: 'gamepad1', symbol: 'üçÜ', start: { x: 1, y: ROWS - 2 }, controls: { type: 'gamepad' } }
    ];
    let keysPressed = {};
    let activeControlIds = new Set();

    const powerUpTypes = {
        range: { symbol: 'üî•' },
        extra_bomb: { symbol: 'üí£' },
        walk_walls: { symbol: 'üí®' },
        walk_bombs: { symbol: 'üõ°Ô∏è' },
        kick_bomb: { symbol: 'üëü' },
    };
    const allPowerUpTypes = Object.keys(powerUpTypes);
    const levelDesigns = {
        1: { name: "D≈æungle", bgColor: '#4CAF50', enemyType: 'üêµ', enemyName: "Opice", enemyCount: 3, wallType: 'üå≥', destructibleWallType: 'üåø' },
        2: { name: "Hory", bgColor: '#a0d2eb', enemyType: 'üßä', enemyName: "Rampouchy", enemyCount: 4, wallType: '‚õ∞Ô∏è', destructibleWallType: '‚ùÑÔ∏è' },
        3: { name: "Hrad - 1. patro", bgColor: '#6c757d', enemyType: 'üëª', enemyName: "Duchov√©", enemyCount: 5, wallType: 'üß±', destructibleWallType: 'üõ¢Ô∏è' },
        4: { name: "Hrad - 2. patro", bgColor: '#495057', enemyType: 'üëª', enemyName: "Duchov√©", enemyCount: 6, wallType: 'üß±', destructibleWallType: 'üõ¢Ô∏è' },
        5: { name: "Hrad - Tr≈Ønn√≠ s√°l" }
    };

    function createPlayer(config) {
        return {
            ...config,
            x: config.start.x, y: config.start.y,
            lives: 3, bombsMax: 1, bombRange: 1,
            isAlive: true, canWalkThroughWalls: false, canWalkThroughBombs: false, canKickBomb: false,
            isHit: false, hitTimer: 0, moveCooldown: 0, bombCooldown: 0,
        };
    }

    // --- Pomocn√© a UI funkce ---
    function getTile(x, y) {
        if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return TILES.INDESTRUCTIBLE;
        return levelMap[y][x];
    }
    function isBombAt(x, y) { return bombs.some(bomb => bomb.x === x && bomb.y === y); }

    function showModal(title, text, buttonText, onButtonClick) {
        gameState.isPaused = true;
        const modal = document.getElementById('messageModal');
        document.getElementById('modalTitle').innerText = title;
        document.getElementById('modalText').innerText = text;
        const button = document.getElementById('modalButton');
        button.innerText = buttonText;
        button.onclick = () => {
            modal.style.display = 'none';
            if (onButtonClick) onButtonClick();
        };
        modal.style.display = 'flex';
    }
    
    function updateInfoPanel() {
        const infoPanel = document.getElementById('infoPanel');
        infoPanel.innerHTML = '';
        if (!gameState.gameActive) return;
        players.forEach((p, i) => {
            const playerDiv = document.createElement('div');
            playerDiv.className = 'player-info';
            const livesHTML = p.symbol.repeat(p.lives);
            playerDiv.innerHTML = `<span>Hr√°ƒç ${i+1}:</span> <span>${livesHTML}</span>`;
            infoPanel.appendChild(playerDiv);
        });
    }

    // --- Generov√°n√≠ levelu ---
    function generateLevel() {
        levelMap = Array.from({ length: ROWS }, () => Array(COLS).fill(TILES.EMPTY));
        for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) {
            if (y === 0 || y === ROWS - 1 || x === 0 || x === COLS - 1 || (y % 2 === 0 && x % 2 === 0)) {
                levelMap[y][x] = TILES.INDESTRUCTIBLE;
            }
        }
        let destructibleWalls = [];
        for (let y = 1; y < ROWS - 1; y++) {
            for (let x = 1; x < COLS - 1; x++) {
                const isStartArea = PLAYER_CONFIG.some(p => Math.abs(p.start.x - x) < 2 && Math.abs(p.start.y - y) < 2);
                if (levelMap[y][x] === TILES.EMPTY && !isStartArea) {
                     if(Math.random() > 0.2) {
                        levelMap[y][x] = TILES.DESTRUCTIBLE;
                        destructibleWalls.push({x, y});
                     }
                }
            }
        }
        
        // Dynamick√Ω poƒçet bonus≈Ø
        const numPowerUps = Math.min(1 + players.length, destructibleWalls.length);
        for(let i = 0; i < numPowerUps; i++) {
            const powerUpKey = allPowerUpTypes[Math.floor(Math.random() * allPowerUpTypes.length)];
            const wallIndex = Math.floor(Math.random() * destructibleWalls.length);
            const wall = destructibleWalls.splice(wallIndex, 1)[0];
            const p = powerUpTypes[powerUpKey];
            powerUps.push({x: wall.x, y: wall.y, type: powerUpKey, symbol: p.symbol});
        }
    }

    function spawnEntities() {
        const levelData = levelDesigns[gameState.currentLevel];
        gameState.enemiesRemaining = levelData.enemyCount;
        enemies = [];
        for (let i = 0; i < levelData.enemyCount; i++) {
            let placed = false;
            while (!placed) {
                const x = Math.floor(Math.random() * (COLS - 2)) + 1;
                const y = Math.floor(Math.random() * (ROWS - 2)) + 1;
                if (getTile(x, y) === TILES.EMPTY) {
                    enemies.push({ x, y, type: levelData.enemyType, direction: {x:0, y:0}, moveCounter: 0 });
                    placed = true;
                }
            }
        }
    }

    function initializeLevel(level) {
        gameState.isPaused = false;
        gameState.currentLevel = level;
        players.forEach(p => { p.x = p.start.x; p.y = p.start.y; });
        bombs = []; explosions = []; powerUps = [];
        generateLevel();
        spawnEntities();
        updateInfoPanel();
        if (document.getElementById('messageModal').style.display === 'flex') {
            gameLoop();
        }
    }
    
    function resetAndStartLobby() {
        gameState.gameActive = false;
        gameState.isPaused = false;
        gameState.killCount = 0;
        players = [];
        activeControlIds.clear();
        initializeLevel(1);
        gameLoop();
    }

    // --- Hern√≠ smyƒçka ---
    function gameLoop() {
        if (gameState.isPaused) return;
        handleInputs();
        if (gameState.gameActive) {
            update();
        }
        draw();
        requestAnimationFrame(gameLoop);
    }

    // --- Update logika ---
    function update() {
        players.forEach(p => {
            if (p.moveCooldown > 0) p.moveCooldown--;
            if (p.bombCooldown > 0) p.bombCooldown--;
            if (p.isHit) {
                p.hitTimer--;
                if (p.hitTimer <= 0) p.isHit = false;
            }
        });
        moveEnemies();
        updateBombs();
        checkCollisions();
    }
    
    function moveEnemies() {
        enemies.forEach(enemy => {
            enemy.moveCounter--;
            if (enemy.moveCounter <= 0) {
                const directions = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];
                enemy.direction = directions[Math.floor(Math.random() * directions.length)];
                enemy.moveCounter = Math.floor(Math.random() * 60) + 30;
            }
            const nextX = enemy.x + enemy.direction.x;
            const nextY = enemy.y + enemy.direction.y;
            if (getTile(nextX, nextY) === TILES.EMPTY && !isBombAt(nextX, nextY) && Math.random() < 0.02) {
                enemy.x = nextX;
                enemy.y = nextY;
            } else if (getTile(nextX, nextY) !== TILES.EMPTY || isBombAt(nextX, nextY)) {
                enemy.moveCounter = 0;
            }
        });
    }

    function updateBombs() {
        explosions = explosions.filter(e => --e.timer > 0);
        bombs.forEach(bomb => {
            if (bomb.isKicked) {
                bomb.kickTimer--;
                if (bomb.kickTimer <= 0) {
                    bomb.kickTimer = 8;
                    const nextX = bomb.x + bomb.vx;
                    const nextY = bomb.y + bomb.vy;
                    if (getTile(nextX, nextY) === TILES.EMPTY && !isBombAt(nextX, nextY)) {
                        bomb.x = nextX;
                        bomb.y = nextY;
                    } else {
                        bomb.isKicked = false;
                    }
                }
            }
            bomb.timer--;
            if (bomb.timer <= 0 && !bomb.exploded) {
                triggerExplosion(bomb);
            }
        });
        bombs = bombs.filter(bomb => !bomb.exploded);
    }

    function triggerExplosion(bomb) {
        if (bomb.exploded) return;
        bomb.exploded = true;
        const owner = players.find(p => p.id === bomb.ownerId);
        createExplosion(bomb.x, bomb.y, owner ? owner.bombRange : 1);
    }

    function createExplosion(x, y, range) {
        const explosionTiles = [{ x, y, timer: 20 }];
        const directions = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];
        directions.forEach(dir => {
            for (let i = 1; i <= range; i++) {
                const ex = x + dir.x * i;
                const ey = y + dir.y * i;
                const tile = getTile(ex, ey);
                if (tile === TILES.INDESTRUCTIBLE) break;
                explosionTiles.push({ x: ex, y: ey, timer: 20 });
                bombs.forEach(b => { if(b.x === ex && b.y === ey) triggerExplosion(b); });
                if (tile === TILES.DESTRUCTIBLE) {
                    levelMap[ey][ex] = TILES.EMPTY;
                    break;
                }
            }
        });
        explosions.push(...explosionTiles);
    }

    function checkCollisions() {
        const currentEnemyName = levelDesigns[gameState.currentLevel].enemyName.slice(0, -1).toLowerCase();
        players.forEach((p) => {
            if (!p.isAlive || p.isHit) return;
            let hit = false;
            enemies.forEach(enemy => { if (enemy.x === p.x && enemy.y === p.y) hit = `Chytil tƒõ ${currentEnemyName}!`; });
            explosions.forEach(exp => { if (exp.x === p.x && exp.y === p.y) hit = "Zas√°hla tƒõ exploze!"; });
            if (hit) handlePlayerHit(p, hit);
        });

        explosions.forEach(exp => {
            enemies = enemies.filter(enemy => {
                if (enemy.x === exp.x && enemy.y === exp.y) {
                    gameState.enemiesRemaining--;
                    gameState.killCount++;
                    if (gameState.killCount > 0 && gameState.killCount % 18 === 0) {
                        players.forEach(p => { if(p.isAlive) p.lives++; });
                    }
                    updateInfoPanel();
                    return false;
                }
                return true;
            });
        });
        
        players.forEach(p => {
             powerUps.forEach((powerUp, index) => {
                if(getTile(powerUp.x, powerUp.y) === TILES.EMPTY && p.x === powerUp.x && p.y === powerUp.y) {
                    switch(powerUp.type) {
                        case 'range': p.bombRange++; break;
                        case 'extra_bomb': p.bombsMax++; break;
                        case 'walk_walls': p.canWalkThroughWalls = true; break;
                        case 'walk_bombs': p.canWalkThroughBombs = true; break;
                        case 'kick_bomb': p.canKickBomb = true; break;
                    }
                    powerUps.splice(index, 1);
                }
            });
        });

        if (gameState.gameActive && gameState.enemiesRemaining <= 0) levelComplete();
    }
    
    // --- Stavy hr√°ƒçe a postup ---
    function handlePlayerHit(player, reason) {
        if (!player.isAlive) return;
        player.lives--;
        if (player.lives <= 0) {
            player.isAlive = false;
        } else {
            player.isHit = true;
            player.hitTimer = 120;
            player.x = player.start.x;
            player.y = player.start.y;
        }
        updateInfoPanel();
        
        if (players.every(pl => !pl.isAlive)) {
            gameOver(reason);
        }
    }

    function gameOver(reason) {
        gameState.gameActive = false;
        showModal("Konec hry!", reason, "Hr√°t znovu?", resetAndStartLobby);
    }

    function levelComplete() {
        gameState.isPaused = true;
        const nextLevel = gameState.currentLevel + 1;
        if (levelDesigns[nextLevel] && nextLevel < 5) {
            showModal("Level dokonƒçen!", "Poraƒè si s dal≈°√≠ v√Ωzvou.", "Dal≈°√≠ level", () => initializeLevel(nextLevel));
        } else {
            showFinalScene();
        }
    }

    function showFinalScene() {
        const dialogue = "Kr√°l ban√°n≈Ø üëë: 'Skvƒõl√° pr√°ce, ovocn√≠ hrdinov√©! Prok√°zali jste velkou odvahu a spolupr√°ci. Jste hodni svobody!'";
        showModal("Setk√°n√≠ s kr√°lem", dialogue, "Hr√°t znovu?", resetAndStartLobby);
    }

    // --- Kreslen√≠ ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const levelData = levelDesigns[gameState.currentLevel];
        canvas.style.backgroundColor = levelData.bgColor;

        ctx.font = `${TILE_SIZE * 0.8}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Kreslen√≠ zd√≠
        ctx.fillStyle = 'black';
        for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) {
            const tile = getTile(x, y);
            let symbol = '';
            if (tile === TILES.INDESTRUCTIBLE) symbol = levelData.wallType;
            if (tile === TILES.DESTRUCTIBLE) symbol = levelData.destructibleWallType;
            if (symbol) ctx.fillText(symbol, x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
        }
        
        if (!gameState.gameActive) {
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(0, canvas.height / 2 - 30, canvas.width, 60);
            ctx.fillStyle = "white";
            ctx.font = "20px 'Press Start 2P'";
            ctx.fillText("Stisknƒõte kl√°vesu nebo tlaƒç√≠tko", canvas.width / 2, canvas.height / 2 - 10);
            ctx.fillText("pro p≈ôipojen√≠ do hry!", canvas.width / 2, canvas.height / 2 + 20);
            return;
        }
        
        powerUps.forEach(p => { if(getTile(p.x, p.y) === TILES.EMPTY) ctx.fillText(p.symbol, p.x * TILE_SIZE + TILE_SIZE / 2, p.y * TILE_SIZE + TILE_SIZE / 2); });
        bombs.forEach(bomb => ctx.fillText('üí£', bomb.x * TILE_SIZE + TILE_SIZE / 2, bomb.y * TILE_SIZE + TILE_SIZE / 2));
        
        explosions.forEach(exp => {
            const centerX = exp.x * TILE_SIZE + TILE_SIZE / 2;
            const centerY = exp.y * TILE_SIZE + TILE_SIZE / 2;
            const progress = exp.timer / 20;
            const grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, TILE_SIZE / 2 * progress);
            grad.addColorStop(0, 'white'); grad.addColorStop(0.5, 'yellow'); grad.addColorStop(1, 'rgba(255, 165, 0, 0.7)');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(centerX, centerY, TILE_SIZE / 2 * progress, 0, 2 * Math.PI); ctx.fill();
        });

        players.forEach(p => {
            if (p.isAlive) {
                ctx.save();
                ctx.globalAlpha = (p.isHit && Math.floor(p.hitTimer / 10) % 2 === 0) ? 0.5 : 1.0;
                ctx.fillStyle = 'black'; // Reset fill style for symbols
                ctx.fillText(p.symbol, p.x * TILE_SIZE + TILE_SIZE / 2, p.y * TILE_SIZE + TILE_SIZE / 2);
                ctx.restore();
            }
        });
        
        ctx.fillStyle = 'black'; // Reset color for enemies
        enemies.forEach(enemy => ctx.fillText(enemy.type, enemy.x * TILE_SIZE + TILE_SIZE / 2, enemy.y * TILE_SIZE + TILE_SIZE / 2));
    }

    // --- Ovl√°d√°n√≠ ---
    function placeBomb(player) {
        if (!player || !player.isAlive || player.bombCooldown > 0) return;
        if (bombs.filter(b => b.ownerId === player.id).length < player.bombsMax && !isBombAt(player.x, player.y)) {
            bombs.push({ x: player.x, y: player.y, timer: 120, exploded: false, ownerId: player.id, isKicked: false, vx: 0, vy: 0, kickTimer: 0 });
            player.bombCooldown = 10;
        }
    }

    function movePlayer(player, dx, dy) {
        if (!player || !player.isAlive || player.moveCooldown > 0) return;
        
        const newX = player.x + dx;
        const newY = player.y + dy;
        const targetTile = getTile(newX, newY);
        const bombAtTarget = bombs.find(b => b.x === newX && b.y === newY);

        if (player.canKickBomb && bombAtTarget && !bombAtTarget.isKicked) {
            bombAtTarget.isKicked = true;
            bombAtTarget.vx = dx;
            bombAtTarget.vy = dy;
            bombAtTarget.kickTimer = 8;
            player.moveCooldown = 7;
            return;
        }

        let canMove = false;
        if (targetTile === TILES.EMPTY || (targetTile === TILES.DESTRUCTIBLE && player.canWalkThroughWalls)) canMove = true;
        if (bombAtTarget && !player.canWalkThroughBombs) canMove = false;
        if (canMove) { player.x = newX; player.y = newY; player.moveCooldown = 7; }
    }

    function handleInputs() {
        // Potvrzen√≠ modalu
        if (gameState.isPaused) {
            const confirmKeyPressed = keysPressed['enter'];
            let confirmGamepadPressed = false;
            const gamepads = navigator.getGamepads();
            for (const gp of gamepads) {
                if (gp && gp.buttons[0].pressed) {
                    confirmGamepadPressed = true;
                    break;
                }
            }
            if (confirmKeyPressed || confirmGamepadPressed) {
                const modalButton = document.getElementById('modalButton');
                if (modalButton) {
                    // Prevent multiple clicks
                    if (!modalButton.disabled) {
                         modalButton.click();
                         modalButton.disabled = true;
                         setTimeout(() => { modalButton.disabled = false; }, 500);
                    }
                }
            }
            return;
        }

        // P≈ôid√°n√≠ nov√Ωch hr√°ƒç≈Ø
        if (players.length < 4) {
            // Kl√°vesnice
            for (const key in keysPressed) {
                if (keysPressed[key]) {
                    const config = PLAYER_CONFIG.find(c => c.controls.type === 'keyboard' && Object.values(c.controls).includes(key));
                    if (config && !activeControlIds.has(config.id)) {
                        players.push(createPlayer(config));
                        activeControlIds.add(config.id);
                        if (!gameState.gameActive) gameState.gameActive = true;
                        updateInfoPanel();
                    }
                }
            }
            // Gamepady
            const gamepads = navigator.getGamepads();
            for (const gp of gamepads) {
                if (!gp) continue;
                const gamepadId = `gamepad${gp.index}`;
                const isActive = gp.buttons.some(b => b.pressed) || gp.axes.some(a => Math.abs(a) > 0.5);
                if (isActive && !activeControlIds.has(gamepadId)) {
                     const config = PLAYER_CONFIG.find(c => c.controls.type === 'gamepad' && !activeControlIds.has(c.id));
                     if (config) {
                         const newPlayer = createPlayer(config);
                         newPlayer.id = gamepadId; // Unique ID for this gamepad
                         newPlayer.controls.index = gp.index;
                         players.push(newPlayer);
                         activeControlIds.add(gamepadId);
                         activeControlIds.add(config.id); // Mark the base config as used
                         if (!gameState.gameActive) gameState.gameActive = true;
                         updateInfoPanel();
                     }
                }
            }
        }

        // Ovl√°d√°n√≠ aktivn√≠ch hr√°ƒç≈Ø
        players.forEach(p => {
            if (!p.isAlive) return;
            if (p.controls.type === 'keyboard') {
                if (keysPressed[p.controls.up]) movePlayer(p, 0, -1);
                else if (keysPressed[p.controls.down]) movePlayer(p, 0, 1);
                else if (keysPressed[p.controls.left]) movePlayer(p, -1, 0);
                else if (keysPressed[p.controls.right]) movePlayer(p, 1, 0);
                if (keysPressed[p.controls.bomb]) placeBomb(p);
            } else if (p.controls.type === 'gamepad') {
                const gp = navigator.getGamepads()[p.controls.index];
                if (!gp) return;
                if (gp.buttons[0].pressed) placeBomb(p);
                const deadzone = 0.5;
                const dx = gp.axes[0];
                const dy = gp.axes[1];
                if (Math.abs(dx) > deadzone) movePlayer(p, Math.sign(dx), 0);
                else if (Math.abs(dy) > deadzone) movePlayer(p, 0, Math.sign(dy));
            }
        });
    }

    window.addEventListener('keydown', (e) => { keysPressed[e.key.toLowerCase()] = true; });
    window.addEventListener('keyup', (e) => { keysPressed[e.key.toLowerCase()] = false; });

    // --- Spu≈°tƒõn√≠ hry ---
    resetAndStartLobby();

</script>
</body>
</html>
